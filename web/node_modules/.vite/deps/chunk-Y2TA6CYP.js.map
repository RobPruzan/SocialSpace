{
  "version": 3,
  "sources": ["../../@tanstack/store/src/index.ts", "../../@tanstack/react-store/src/index.tsx", "../../@tanstack/router/src/history.ts", "../../@tanstack/router/src/utils.ts", "../../@tanstack/router/src/path.ts", "../../@tanstack/router/src/qss.ts", "../../@tanstack/router/src/react.tsx", "../../@tanstack/router/src/route.ts", "../../@tanstack/router/src/searchParams.ts", "../../@tanstack/router/src/router.ts"],
  "sourcesContent": ["export type AnyUpdater = (...args: any[]) => any\n\nexport type Listener = (opts: { priority: Priority }) => void\n\nexport type Priority = 'high' | 'low'\n\ninterface StoreOptions<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  updateFn?: (previous: TState) => (updater: TUpdater) => TState\n  onSubscribe?: (\n    listener: Listener,\n    store: Store<TState, TUpdater>,\n  ) => () => void\n  onUpdate?: (opts: { priority: Priority }) => void\n  defaultPriority?: Priority\n}\n\nexport class Store<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  listeners = new Set<Listener>()\n  state: TState\n  options?: StoreOptions<TState, TUpdater>\n  _batching = false\n  _flushing = 0\n  _nextPriority: null | Priority = null\n\n  constructor(initialState: TState, options?: StoreOptions<TState, TUpdater>) {\n    this.state = initialState\n    this.options = options\n  }\n\n  subscribe = (listener: Listener) => {\n    this.listeners.add(listener)\n    const unsub = this.options?.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n\n  setState = (\n    updater: TUpdater,\n    opts?: {\n      priority: Priority\n    },\n  ) => {\n    const previous = this.state\n    this.state = this.options?.updateFn\n      ? this.options.updateFn(previous)(updater)\n      : (updater as any)(previous)\n\n    const priority = opts?.priority ?? this.options?.defaultPriority ?? 'high'\n    if (this._nextPriority === null) {\n      this._nextPriority = priority\n    } else if (this._nextPriority === 'high') {\n      this._nextPriority = priority\n    } else {\n      this._nextPriority = this.options?.defaultPriority ?? 'high'\n    }\n\n    // Always run onUpdate, regardless of batching\n    this.options?.onUpdate?.({\n      priority: this._nextPriority,\n    })\n\n    // Attempt to flush\n    this._flush()\n  }\n\n  _flush = () => {\n    if (this._batching) return\n    const flushId = ++this._flushing\n    this.listeners.forEach((listener) => {\n      if (this._flushing !== flushId) return\n      listener({\n        priority: this._nextPriority ?? 'high',\n      })\n    })\n  }\n\n  batch = (cb: () => void) => {\n    if (this._batching) return cb()\n    this._batching = true\n    cb()\n    this._batching = false\n    this._flush()\n  }\n}\n", "import * as React from 'react'\nimport { AnyUpdater, Store } from '@tanstack/store'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector'\n\nexport * from '@tanstack/store'\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport function useStore<\n  TState,\n  TSelected = NoInfer<TState>,\n  TUpdater extends AnyUpdater = AnyUpdater,\n>(\n  store: Store<TState, TUpdater>,\n  selector: (state: NoInfer<TState>) => TSelected = (d) => d as any,\n) {\n  const slice = useSyncExternalStoreWithSelector(\n    store.subscribe,\n    () => store.state,\n    () => store.state,\n    selector,\n    shallow,\n  )\n\n  return slice\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n", "// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nexport interface RouterHistory {\n  location: RouterLocation\n  listen: (cb: () => void) => () => void\n  push: (path: string, state?: any) => void\n  replace: (path: string, state?: any) => void\n  go: (index: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (href: string) => string\n  block: (blockerFn: BlockerFn) => () => void\n}\n\nexport interface ParsedPath {\n  href: string\n  pathname: string\n  search: string\n  hash: string\n}\n\nexport interface RouterLocation extends ParsedPath {\n  state: any\n}\n\ntype BlockerFn = (retry: () => void, cancel: () => void) => void\n\nconst popStateEvent = 'popstate'\nconst beforeUnloadEvent = 'beforeunload'\n\nconst beforeUnloadListener = (event: Event) => {\n  event.preventDefault()\n  // @ts-ignore\n  return (event.returnValue = '')\n}\n\nconst stopBlocking = () => {\n  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n    capture: true,\n  })\n}\n\nfunction createHistory(opts: {\n  getLocation: () => RouterLocation\n  listener: (onUpdate: () => void) => () => void\n  pushState: (path: string, state: any) => void\n  replaceState: (path: string, state: any) => void\n  go: (n: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (path: string) => string\n}): RouterHistory {\n  let location = opts.getLocation()\n  let unsub = () => {}\n  let listeners = new Set<() => void>()\n  let blockers: BlockerFn[] = []\n  let queue: (() => void)[] = []\n\n  const tryFlush = () => {\n    if (blockers.length) {\n      blockers[0]?.(tryFlush, () => {\n        blockers = []\n        stopBlocking()\n      })\n      return\n    }\n\n    while (queue.length) {\n      queue.shift()?.()\n    }\n\n    onUpdate()\n  }\n\n  const queueTask = (task: () => void) => {\n    queue.push(task)\n    tryFlush()\n  }\n\n  const onUpdate = () => {\n    location = opts.getLocation()\n    listeners.forEach((listener) => listener())\n  }\n\n  return {\n    get location() {\n      return location\n    },\n    listen: (cb: () => void) => {\n      if (listeners.size === 0) {\n        unsub = opts.listener(onUpdate)\n      }\n      listeners.add(cb)\n\n      return () => {\n        listeners.delete(cb)\n        if (listeners.size === 0) {\n          unsub()\n        }\n      }\n    },\n    push: (path: string, state: any) => {\n      queueTask(() => {\n        opts.pushState(path, state)\n      })\n    },\n    replace: (path: string, state: any) => {\n      queueTask(() => {\n        opts.replaceState(path, state)\n      })\n    },\n    go: (index) => {\n      queueTask(() => {\n        opts.go(index)\n      })\n    },\n    back: () => {\n      queueTask(() => {\n        opts.back()\n      })\n    },\n    forward: () => {\n      queueTask(() => {\n        opts.forward()\n      })\n    },\n    createHref: (str) => opts.createHref(str),\n    block: (cb) => {\n      blockers.push(cb)\n\n      if (blockers.length === 1) {\n        addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n          capture: true,\n        })\n      }\n\n      return () => {\n        blockers = blockers.filter((b) => b !== cb)\n\n        if (!blockers.length) {\n          stopBlocking()\n        }\n      }\n    },\n  }\n}\n\nexport function createBrowserHistory(opts?: {\n  getHref?: () => string\n  createHref?: (path: string) => string\n}): RouterHistory {\n  const getHref =\n    opts?.getHref ??\n    (() =>\n      `${window.location.pathname}${window.location.search}${window.location.hash}`)\n  const createHref = opts?.createHref ?? ((path) => path)\n  const getLocation = () => parseLocation(getHref(), history.state)\n\n  return createHistory({\n    getLocation,\n    listener: (onUpdate) => {\n      window.addEventListener(popStateEvent, onUpdate)\n      return () => {\n        window.removeEventListener(popStateEvent, onUpdate)\n      }\n    },\n    pushState: (path, state) => {\n      window.history.pushState(\n        { ...state, key: createRandomKey() },\n        '',\n        createHref(path),\n      )\n    },\n    replaceState: (path, state) => {\n      window.history.replaceState(\n        { ...state, key: createRandomKey() },\n        '',\n        createHref(path),\n      )\n    },\n    back: () => window.history.back(),\n    forward: () => window.history.forward(),\n    go: (n) => window.history.go(n),\n    createHref: (path) => createHref(path),\n  })\n}\n\nexport function createHashHistory(): RouterHistory {\n  return createBrowserHistory({\n    getHref: () => window.location.hash.substring(1),\n    createHref: (path) => `#${path}`,\n  })\n}\n\nexport function createMemoryHistory(\n  opts: {\n    initialEntries: string[]\n    initialIndex?: number\n  } = {\n    initialEntries: ['/'],\n  },\n): RouterHistory {\n  const entries = opts.initialEntries\n  let index = opts.initialIndex ?? entries.length - 1\n  let currentState = {}\n\n  const getLocation = () => parseLocation(entries[index]!, currentState)\n\n  return createHistory({\n    getLocation,\n    listener: () => {\n      return () => {}\n    },\n    pushState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey(),\n      }\n      entries.push(path)\n      index++\n    },\n    replaceState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey(),\n      }\n      entries[index] = path\n    },\n    back: () => {\n      index--\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1)\n    },\n    go: (n) => window.history.go(n),\n    createHref: (path) => path,\n  })\n}\n\nfunction parseLocation(href: string, state: any): RouterLocation {\n  let hashIndex = href.indexOf('#')\n  let searchIndex = href.indexOf('?')\n\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0\n        ? searchIndex > 0\n          ? Math.min(hashIndex, searchIndex)\n          : hashIndex\n        : searchIndex > 0\n        ? searchIndex\n        : href.length,\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : '',\n    search:\n      searchIndex > -1\n        ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex)\n        : '',\n    state,\n  }\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7)\n}\n", "export type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = {\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\ntype Compute<T> = { [K in keyof T]: T[K] } | never\n\ntype AllKeys<T> = T extends any ? keyof T : never\n\nexport type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<\n  {\n    [K in Keys]: T[Keys]\n  } & {\n    [K in AllKeys<T>]?: T extends any\n      ? K extends keyof T\n        ? T[K]\n        : never\n      : never\n  }\n>\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult>,\n  previous: TResult,\n) {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const prevSize = array ? prev.length : Object.keys(prev).length\n    const nextItems = array ? next : Object.keys(next)\n    const nextSize = nextItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return (\n      a.length === b.length &&\n      a.every((item, index) => partialDeepEqual(item, b[index]))\n    )\n  }\n\n  return false\n}\n", "import { AnyPathParams } from './route'\nimport { MatchLocation } from './router'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcards: boolean = false,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === 'wildcard') {\n        const value = params[segment.value]\n        if (leaveWildcards) return `${segment.value}${value ?? ''}`\n        return value\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  // Remove the base path from the pathname\n  from = basepath != '/' ? from.substring(basepath.length) : from\n  // Default to to $ (wildcard)\n  const to = `${matchLocation.to ?? '$'}`\n  // Parse the from and to\n  const baseSegments = parsePathname(from)\n  const routeSegments = parsePathname(to)\n\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastBaseSegment = i >= baseSegments.length - 1\n      const isLastRouteSegment = i >= routeSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n", "// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  if (str.charAt(0) === '0') return str\n  return +str * 0 === 0 ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n", "import * as React from 'react'\nimport { NoInfer, useStore } from '@tanstack/react-store'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\n// @ts-ignore\nimport {\n  LinkOptions,\n  ToOptions,\n  ResolveRelativePath,\n  NavigateOptions,\n} from './link'\nimport { AnyRoute } from './route'\nimport { RouteByPath, AnyRoutesInfo, DefaultRoutesInfo } from './routeInfo'\nimport {\n  RegisteredRoutesInfo,\n  MatchRouteOptions,\n  RegisteredRouter,\n  RouterOptions,\n  Router,\n  RouteMatch,\n} from './router'\nimport { functionalUpdate, last, pick } from './utils'\n\n//\n\nexport { useStore }\n\n//\n\ntype ReactNode = any\n\nexport type SyncRouteComponent<TProps = {}> = (props: TProps) => ReactNode\n\nexport type RouteComponent<TProps = {}> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport function lazy<T extends Record<string, SyncRouteComponent>>(\n  importer: () => Promise<T>,\n  exportName: keyof T = 'default',\n): RouteComponent {\n  const lazyComp = React.lazy(async () => {\n    const moduleExports = await importer()\n    const component = moduleExports[exportName]\n    return { default: component }\n  })\n\n  let preloaded: Promise<SyncRouteComponent>\n\n  const finalComp = lazyComp as unknown as RouteComponent\n\n  finalComp.preload = async () => {\n    if (!preloaded) {\n      await importer()\n    }\n  }\n\n  return finalComp\n}\n\nexport type LinkPropsOptions<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = LinkOptions<RegisteredRoutesInfo, TFrom, TTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // If set to `true`, the link's underlying navigate() call will be wrapped in a `React.startTransition` call. Defaults to `true`.\n  startTransition?: boolean\n}\n\nexport type MakeUseMatchRouteOptions<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = ToOptions<RegisteredRoutesInfo, TFrom, TTo> & MatchRouteOptions\n\nexport type MakeMatchRouteOptions<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = ToOptions<RegisteredRoutesInfo, TFrom, TTo> &\n  MatchRouteOptions & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | ((\n          params?: RouteByPath<\n            RegisteredRoutesInfo,\n            ResolveRelativePath<TFrom, NoInfer<TTo>>\n          >['__types']['allParams'],\n        ) => ReactNode)\n      | React.ReactNode\n  }\n\nexport type MakeLinkPropsOptions<\n  TFrom extends string = '/',\n  TTo extends string = '',\n> = LinkPropsOptions<TFrom, TTo> & React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type MakeLinkOptions<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = LinkPropsOptions<TFrom, TTo> &\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | React.ReactNode\n      | ((state: { isActive: boolean }) => React.ReactNode)\n  }\n\nexport type PromptProps = {\n  message: string\n  condition?: boolean | any\n  children?: ReactNode\n}\n\n//\n\nexport function useLinkProps<\n  TFrom extends string = '/',\n  TTo extends string = '',\n>(\n  options: MakeLinkPropsOptions<TFrom, TTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const router = useRouter()\n\n  const {\n    // custom props\n    type,\n    children,\n    target,\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    // fromCurrent,\n    hash,\n    search,\n    params,\n    to = '.',\n    preload,\n    preloadDelay,\n    replace,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options\n\n  const linkInfo = router.buildLink(options as any)\n\n  if (linkInfo.type === 'external') {\n    const { href } = linkInfo\n    return { href }\n  }\n\n  const {\n    handleClick,\n    handleFocus,\n    handleEnter,\n    handleLeave,\n    handleTouchStart,\n    isActive,\n    next,\n  } = linkInfo\n\n  const handleReactClick = (e: Event) => {\n    if (options.startTransition ?? true) {\n      ;(React.startTransition || ((d) => d))(() => {\n        handleClick(e)\n      })\n    }\n  }\n\n  const composeHandlers =\n    (handlers: (undefined | ((e: any) => void))[]) =>\n    (e: React.SyntheticEvent) => {\n      if (e.persist) e.persist()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps as any, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {}\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled ? undefined : next.href,\n    onClick: composeHandlers([onClick, handleReactClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style,\n    },\n    className:\n      [\n        className,\n        resolvedActiveProps.className,\n        resolvedInactiveProps.className,\n      ]\n        .filter(Boolean)\n        .join(' ') || undefined,\n    ...(disabled\n      ? {\n          role: 'link',\n          'aria-disabled': true,\n        }\n      : undefined),\n    ['data-status']: isActive ? 'active' : undefined,\n  }\n}\n\nexport interface LinkFn<\n  TDefaultFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TDefaultTo extends string = '',\n> {\n  <\n    TFrom extends RegisteredRoutesInfo['routePaths'] = TDefaultFrom,\n    TTo extends string = TDefaultTo,\n  >(\n    props: MakeLinkOptions<TFrom, TTo> & React.RefAttributes<HTMLAnchorElement>,\n  ): ReactNode\n}\n\nexport const Link: LinkFn = React.forwardRef((props: any, ref) => {\n  const linkProps = useLinkProps(props)\n\n  return (\n    <a\n      {...{\n        ref: ref as any,\n        ...linkProps,\n        children:\n          typeof props.children === 'function'\n            ? props.children({\n                isActive: (linkProps as any)['data-status'] === 'active',\n              })\n            : props.children,\n      }}\n    />\n  )\n}) as any\n\nexport function Navigate<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n>(props: NavigateOptions<RegisteredRoutesInfo, TFrom, TTo>): null {\n  const router = useRouter()\n\n  React.useLayoutEffect(() => {\n    router.navigate(props as any)\n  }, [])\n\n  return null\n}\n\nexport const matchIdsContext = React.createContext<string[]>(null!)\nexport const routerContext = React.createContext<RegisteredRouter>(null!)\n\nexport type RouterProps<\n  TRouteConfig extends AnyRoute = AnyRoute,\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = Omit<RouterOptions<TRouteConfig, TDehydrated>, 'context'> & {\n  router: Router<TRouteConfig, TRoutesInfo>\n  context?: Partial<RouterOptions<TRouteConfig, TDehydrated>['context']>\n}\n\nexport function useRouterState<TSelected = RegisteredRouter['state']>(opts?: {\n  select: (state: RegisteredRouter['state']) => TSelected\n}): TSelected {\n  const router = useRouter()\n  return useStore(router.__store, opts?.select)\n}\n\nexport function RouterProvider<\n  TRouteConfig extends AnyRoute = AnyRoute,\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({ router, ...rest }: RouterProps<TRouteConfig, TRoutesInfo, TDehydrated>) {\n  router.update(rest)\n\n  React.useEffect(router.mount, [router])\n\n  const Wrap = router.options.Wrap || React.Fragment\n\n  return (\n    <Wrap>\n      <routerContext.Provider value={router as any}>\n        <Matches />\n      </routerContext.Provider>\n    </Wrap>\n  )\n}\n\nfunction Matches() {\n  const matchIds = useRouterState({\n    select: (d) => d.matches.map((d) => d.id),\n  })\n\n  return (\n    <matchIdsContext.Provider value={[undefined!, ...matchIds]}>\n      <CatchBoundary\n        errorComponent={ErrorComponent}\n        onCatch={() => {\n          warning(\n            false,\n            `Error in router! Consider setting an 'errorComponent' in your RootRoute! 👍`,\n          )\n        }}\n      >\n        <Outlet />\n      </CatchBoundary>\n    </matchIdsContext.Provider>\n  )\n}\n\nexport function useRouter(): RegisteredRouter {\n  const value = React.useContext(routerContext)\n  warning(value, 'useRouter must be used inside a <Router> component!')\n  return value\n}\n\nexport function useMatches<T = RouteMatch[]>(opts?: {\n  select?: (matches: RouteMatch[]) => T\n}): T {\n  const matchIds = React.useContext(matchIdsContext)\n  return useRouterState({\n    select: (state) => {\n      const matches = state.matches.slice(\n        state.matches.findIndex((d) => d.id === matchIds[0]),\n      )\n      return (opts?.select?.(matches) ?? matches) as T\n    },\n  })\n}\n\nexport function useMatch<\n  TFrom extends keyof RegisteredRoutesInfo['routesById'],\n  TStrict extends boolean = true,\n  TRouteMatchState = RouteMatch<\n    RegisteredRoutesInfo,\n    RegisteredRoutesInfo['routesById'][TFrom]\n  >,\n  TSelected = TRouteMatchState,\n>(opts?: {\n  from: TFrom\n  strict?: TStrict\n  select?: (match: TRouteMatchState) => TSelected\n}): TStrict extends true ? TRouteMatchState : TRouteMatchState | undefined {\n  const router = useRouter()\n  const nearestMatchId = React.useContext(matchIdsContext)[0]!\n  const nearestMatchRouteId = router.getRouteMatch(nearestMatchId)?.routeId\n\n  const matchRouteId = useRouterState({\n    select: (state) => {\n      const matches = state.matches\n      const match = opts?.from\n        ? matches.find((d) => d.routeId === opts?.from)\n        : matches.find((d) => d.id === nearestMatchId)\n\n      return match!.routeId\n    },\n  })\n\n  if (opts?.strict ?? true) {\n    invariant(\n      nearestMatchRouteId == matchRouteId,\n      `useMatch(\"${\n        matchRouteId as string\n      }\") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch(\"${\n        matchRouteId as string\n      }\", { strict: false })' or 'useRoute(\"${\n        matchRouteId as string\n      }\")' instead?`,\n    )\n  }\n\n  const match = useRouterState({\n    select: (state) => {\n      const matches = state.matches\n      const match = opts?.from\n        ? matches.find((d) => d.routeId === opts?.from)\n        : matches.find((d) => d.id === nearestMatchId)\n\n      invariant(\n        match,\n        `Could not find ${\n          opts?.from\n            ? `an active match from \"${opts.from}\"`\n            : 'a nearest match!'\n        }`,\n      )\n\n      return (opts?.select?.(match as any) ?? match) as TSelected\n    },\n  })\n\n  return match as any\n}\n\nexport type RouteFromIdOrRoute<T> = T extends RegisteredRoutesInfo['routeUnion']\n  ? T\n  : T extends keyof RegisteredRoutesInfo['routesById']\n  ? RegisteredRoutesInfo['routesById'][T]\n  : T extends string\n  ? keyof RegisteredRoutesInfo['routesById']\n  : never\n\nexport function useLoader<\n  TFrom extends keyof RegisteredRoutesInfo['routesById'],\n  TStrict extends boolean = true,\n  TLoader = RegisteredRoutesInfo['routesById'][TFrom]['__types']['loader'],\n  TSelected = TLoader,\n>(opts?: {\n  from: TFrom\n  strict?: TStrict\n  select?: (search: TLoader) => TSelected\n}): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...(opts as any),\n    select: (match: RouteMatch) =>\n      (opts?.select?.(match.loader as TLoader) ?? match.loader) as TSelected,\n  })\n}\n\nexport function useSearch<\n  TFrom extends keyof RegisteredRoutesInfo['routesById'],\n  TStrict extends boolean = true,\n  TSearch = RegisteredRoutesInfo['routesById'][TFrom]['__types']['fullSearchSchema'],\n  TSelected = TSearch,\n>(opts?: {\n  from: TFrom\n  strict?: TStrict\n  select?: (search: TSearch) => TSelected\n}): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...(opts as any),\n    select: (match: RouteMatch) => {\n      return (opts?.select?.(match.search as TSearch) ??\n        match.search) as TSelected\n    },\n  })\n}\n\nexport function useParams<\n  TFrom extends keyof RegisteredRoutesInfo['routesById'] = '/',\n  TDefaultSelected = RegisteredRoutesInfo['allParams'] &\n    RegisteredRoutesInfo['routesById'][TFrom]['__types']['allParams'],\n  TSelected = TDefaultSelected,\n>(opts?: {\n  from: TFrom\n  select?: (search: TDefaultSelected) => TSelected\n}): TSelected {\n  return useRouterState({\n    select: (state: any) => {\n      const params = (last(state.matches) as any)?.params\n      return (opts?.select?.(params) ?? params) as TSelected\n    },\n  })\n}\n\nexport function useNavigate<\n  TDefaultFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n>(defaultOpts?: { from?: TDefaultFrom }) {\n  const router = useRouter()\n  return React.useCallback(\n    <\n      TFrom extends RegisteredRoutesInfo['routePaths'] = TDefaultFrom,\n      TTo extends string = '',\n    >(\n      opts?: NavigateOptions<RegisteredRoutesInfo, TFrom, TTo>,\n    ) => {\n      return router.navigate({ ...defaultOpts, ...(opts as any) })\n    },\n    [],\n  )\n}\n\nexport function useMatchRoute() {\n  const router = useRouter()\n\n  return React.useCallback(\n    <TFrom extends string = '/', TTo extends string = ''>(\n      opts: MakeUseMatchRouteOptions<TFrom, TTo>,\n    ) => {\n      const { pending, caseSensitive, ...rest } = opts\n\n      return router.matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n      })\n    },\n    [],\n  )\n}\n\nexport function MatchRoute<TFrom extends string = '/', TTo extends string = ''>(\n  props: MakeMatchRouteOptions<TFrom, TTo>,\n): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props)\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return !!params ? props.children : null\n}\n\nexport function Outlet() {\n  const matchIds = React.useContext(matchIdsContext).slice(1)\n\n  if (!matchIds[0]) {\n    return null\n  }\n\n  return <Match matchIds={matchIds} />\n}\n\nconst defaultPending = () => null\n\nfunction Match({ matchIds }: { matchIds: string[] }) {\n  const router = useRouter()\n  const matchId = matchIds[0]!\n  const routeId = router.getRouteMatch(matchId)!.routeId\n  const route = router.getRoute(routeId)\n\n  const PendingComponent = (route.options.pendingComponent ??\n    router.options.defaultPendingComponent ??\n    defaultPending) as any\n\n  const errorComponent =\n    route.options.errorComponent ?? router.options.defaultErrorComponent\n\n  const ResolvedSuspenseBoundary =\n    route.options.wrapInSuspense ?? !route.isRoot\n      ? React.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = errorComponent ? CatchBoundary : SafeFragment\n\n  return (\n    <matchIdsContext.Provider value={matchIds}>\n      <ResolvedSuspenseBoundary fallback={<PendingComponent />}>\n        <ResolvedCatchBoundary\n          key={route.id}\n          errorComponent={errorComponent}\n          onCatch={() => {\n            warning(false, `Error in route match: ${matchId}`)\n          }}\n        >\n          <MatchInner matchId={matchId} />\n        </ResolvedCatchBoundary>\n      </ResolvedSuspenseBoundary>\n    </matchIdsContext.Provider>\n  )\n}\n\nfunction MatchInner({ matchId }: { matchId: string }): any {\n  const router = useRouter()\n\n  const match = useRouterState({\n    select: (d) =>\n      pick(d.matches.find((d) => d.id === matchId)!, [\n        'status',\n        'loadPromise',\n        'routeId',\n        'error',\n      ]),\n  })\n\n  const route = router.getRoute(match.routeId)\n\n  if (match.status === 'error') {\n    throw match.error\n  }\n\n  if (match.status === 'pending') {\n    invariant(false, 'This should never happen')\n  }\n\n  if (match.status === 'success') {\n    let comp = route.options.component ?? router.options.defaultComponent\n\n    if (comp) {\n      return React.createElement(comp, {\n        useLoader: route.useLoader,\n        useMatch: route.useMatch,\n        useContext: route.useContext,\n        useSearch: route.useSearch,\n        useParams: route.useParams,\n      })\n    }\n\n    return <Outlet />\n  }\n\n  invariant(\n    false,\n    'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n  )\n}\n\nfunction SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n\nexport function useInjectHtml() {\n  const router = useRouter()\n\n  return React.useCallback(\n    (html: string | (() => Promise<string> | string)) => {\n      router.injectHtml(html)\n    },\n    [],\n  )\n}\n\nexport function useDehydrate() {\n  const router = useRouter()\n\n  return React.useCallback(function dehydrate<T>(\n    key: any,\n    data: T | (() => Promise<T> | T),\n  ) {\n    return router.dehydrateData(key, data)\n  },\n  [])\n}\n\nexport function useHydrate() {\n  const router = useRouter()\n\n  return function hydrate<T = unknown>(key: any) {\n    return router.hydrateData(key) as T\n  }\n}\n\n// This is the messiest thing ever... I'm either seriously tired (likely) or\n// there has to be a better way to reset error boundaries when the\n// router's location key changes.\n\nclass CatchBoundary extends React.Component<{\n  children: any\n  errorComponent: any\n  onCatch: (error: any, info: any) => void\n}> {\n  state = {\n    error: false,\n    info: undefined,\n  }\n  componentDidCatch(error: any, info: any) {\n    this.props.onCatch(error, info)\n    this.setState({\n      error,\n      info,\n    })\n  }\n  render() {\n    return (\n      <CatchBoundaryInner\n        {...this.props}\n        errorState={this.state}\n        reset={() => this.setState({})}\n      />\n    )\n  }\n}\n\nfunction CatchBoundaryInner(props: {\n  children: any\n  errorComponent: any\n  errorState: { error: unknown; info: any }\n  reset: () => void\n}) {\n  const locationKey = useRouterState({\n    select: (d) => d.resolvedLocation.key,\n  })\n\n  const [activeErrorState, setActiveErrorState] = React.useState(\n    props.errorState,\n  )\n  const errorComponent = props.errorComponent ?? ErrorComponent\n  const prevKeyRef = React.useRef('' as any)\n\n  React.useEffect(() => {\n    if (activeErrorState) {\n      if (locationKey !== prevKeyRef.current) {\n        setActiveErrorState({} as any)\n      }\n    }\n\n    prevKeyRef.current = locationKey\n  }, [activeErrorState, locationKey])\n\n  React.useEffect(() => {\n    if (props.errorState.error) {\n      setActiveErrorState(props.errorState)\n    }\n    // props.reset()\n  }, [props.errorState.error])\n\n  if (props.errorState.error && activeErrorState.error) {\n    return React.createElement(errorComponent, activeErrorState)\n  }\n\n  return props.children\n}\n\nexport function ErrorComponent({ error }: { error: any }) {\n  return (\n    <div style={{ padding: '.5rem', maxWidth: '100%' }}>\n      <strong style={{ fontSize: '1.2rem' }}>Something went wrong!</strong>\n      <div style={{ height: '.5rem' }} />\n      <div>\n        <pre\n          style={{\n            fontSize: '.7em',\n            border: '1px solid red',\n            borderRadius: '.25rem',\n            padding: '.5rem',\n            color: 'red',\n            overflow: 'auto',\n          }}\n        >\n          {error.message ? <code>{error.message}</code> : null}\n        </pre>\n      </div>\n    </div>\n  )\n}\n\nexport function useBlocker(\n  message: string,\n  condition: boolean | any = true,\n): void {\n  const router = useRouter()\n\n  React.useEffect(() => {\n    if (!condition) return\n\n    let unblock = router.history.block((retry, cancel) => {\n      if (window.confirm(message)) {\n        unblock()\n        retry()\n      }\n    })\n\n    return unblock\n  })\n}\n\nexport function Block({ message, condition, children }: PromptProps) {\n  useBlocker(message, condition)\n  return (children ?? null) as ReactNode\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n", "import { ParsePathParams } from './link'\nimport {\n  AnyRouter,\n  Router,\n  AnyRouteMatch,\n  RouteMatch,\n  RouterConstructorOptions,\n} from './router'\nimport {\n  IsAny,\n  NoInfer,\n  PickRequired,\n  PickUnsafe,\n  UnionToIntersection,\n} from './utils'\nimport invariant from 'tiny-invariant'\nimport { joinPaths, trimPath } from './path'\nimport { AnyRoutesInfo, DefaultRoutesInfo, RoutesInfo } from './routeInfo'\nimport {\n  RouteComponent,\n  useLoader,\n  useMatch,\n  useParams,\n  useSearch,\n} from './react'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\nexport type AnySearchSchema = {}\nexport type AnyContext = {}\nexport interface RouteMeta {}\nexport interface RouteContext {}\n\nexport type RouteOptionsBase<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RouteOptionsBaseIntersection<TCustomId, TPath> =\n  UnionToIntersection<RouteOptionsBase<TCustomId, TPath>>\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\ntype GetContextFn<\n  TParentRoute,\n  TAllParams,\n  TFullSearchSchema,\n  TParentContext,\n  TAllParentContext,\n  TRouteContext,\n> = (\n  opts: {\n    params: TAllParams\n    search: TFullSearchSchema\n  } & (TParentRoute extends undefined\n    ? {\n        context?: TAllParentContext\n        parentContext?: TParentContext\n      }\n    : {\n        context: TAllParentContext\n        parentContext: TParentContext\n      }),\n) => TRouteContext\n\nexport type ContextOptions<\n  TParentRoute,\n  TAllParams,\n  TFullSearchSchema,\n  TParentContext,\n  TAllParentContext,\n  TRouteContext,\n> = keyof PickRequired<RouteContext> extends never\n  ? {\n      getContext?: GetContextFn<\n        TParentRoute,\n        TAllParams,\n        TFullSearchSchema,\n        TParentContext,\n        TAllParentContext,\n        TRouteContext\n      >\n    }\n  : {\n      getContext: GetContextFn<\n        TParentRoute,\n        TAllParams,\n        TFullSearchSchema,\n        TParentContext,\n        TAllParentContext,\n        TRouteContext\n      >\n    }\n\nexport type RouteProps<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TFullPath extends ResolveFullPath<\n    TParentRoute,\n    TPath,\n    RoutePrefix<TParentRoute['fullPath'], TPath>\n  >,\n  TCustomId extends string,\n  TId extends ResolveId<TParentRoute, TCustomId, TPath>,\n  TLoader,\n  TSearchSchema extends AnySearchSchema,\n  TFullSearchSchema extends AnySearchSchema,\n  TAllParams,\n  TParentContext,\n  TAllParentContext extends IsAny<\n    TParentRoute['__types']['allParams'],\n    TParentContext,\n    TParentRoute['__types']['allParams'] & TParentContext\n  >,\n  TRouteContext,\n  TContext,\n  TRouterContext extends AnyContext,\n> = {\n  useMatch: () => RouteMatch<\n    AnyRoutesInfo,\n    Route<\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TLoader,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext,\n      TRouterContext,\n      any,\n      any\n    >\n  >\n  useLoader: () => UseLoaderResult<TLoader>\n  useSearch: <\n    TStrict extends boolean = true,\n    TSearch = TFullSearchSchema,\n    TSelected = TSearch,\n  >(opts?: {\n    strict?: TStrict\n    select?: (search: TSearch) => TSelected\n  }) => TStrict extends true ? TSelected : TSelected | undefined\n  useParams: <\n    TDefaultSelected = TAllParams,\n    TSelected = TDefaultSelected,\n  >(opts?: {\n    select?: (params: TDefaultSelected) => TSelected\n  }) => TSelected\n  useContext: <\n    TDefaultSelected = TContext,\n    TSelected = TDefaultSelected,\n  >(opts?: {\n    select?: (context: TDefaultSelected) => TSelected\n  }) => TSelected\n}\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TLoader = unknown,\n  TParentSearchSchema extends {} = {},\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = TSearchSchema,\n  TParentParams extends AnyPathParams = {},\n  TParams = Record<ParsePathParams<TPath>, string>,\n  TAllParams = TParams,\n  TParentContext extends AnyContext = AnyContext,\n  TAllParentContext extends IsAny<\n    TParentRoute['__types']['allParams'],\n    TParentContext,\n    TParentRoute['__types']['allParams'] & TParentContext\n  > = IsAny<\n    TParentRoute['__types']['allParams'],\n    TParentContext,\n    TParentRoute['__types']['allParams'] & TParentContext\n  >,\n  TRouteContext extends RouteContext = RouteContext,\n  TContext extends MergeFromParent<\n    TAllParentContext,\n    TRouteContext\n  > = MergeFromParent<TAllParentContext, TRouteContext>,\n> = RouteOptionsBase<TCustomId, TPath> & {\n  getParentRoute: () => TParentRoute\n  // Optionally call this function to get a unique key for this route.\n  // This is useful for routes that need to be uniquely identified\n  // by more than their by search params\n  getKey?: OnLoadFnKey<\n    TSearchSchema,\n    TFullSearchSchema,\n    TAllParams,\n    NoInfer<TRouteContext>,\n    TContext\n  >\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent<\n    RouteProps<\n      TParentRoute,\n      TPath,\n      ResolveFullPath<TParentRoute, TPath>,\n      TCustomId,\n      ResolveId<TParentRoute, TCustomId, TPath>,\n      TLoader,\n      TSearchSchema,\n      TFullSearchSchema,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext,\n      NoInfer<TRouteContext>\n    >\n  > //\n  // The content to be rendered when the route encounters an error\n  errorComponent?: RouteComponent<{\n    error: Error\n    info: { componentStack: string }\n  }> //\n  // If supported by your framework, the content to be rendered as the fallback content until the route is ready to render\n  pendingComponent?: RouteComponent<\n    RouteProps<\n      TParentRoute,\n      TPath,\n      ResolveFullPath<TParentRoute, TPath>,\n      TCustomId,\n      ResolveId<TParentRoute, TCustomId, TPath>,\n      TLoader,\n      TSearchSchema,\n      TFullSearchSchema,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext,\n      NoInfer<TRouteContext>\n    >\n  > //\n  wrapInSuspense?: boolean\n\n  // This async function is called before a route is loaded.\n  // If an error is thrown here, the route's loader will not be called.\n  // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onLoadError` function.\n  // If thrown during a preload event, the error will be logged to the console.\n  beforeLoad?: (opts: {\n    router: AnyRouter\n    match: AnyRouteMatch\n  }) => Promise<void> | void\n  // This function will be called if the route's loader throws an error **during an attempted navigation**.\n  // If you want to redirect due to an error, call `router.navigate()` from within this function.\n  onBeforeLoadError?: (err: any) => void\n  validateSearch?: SearchSchemaValidator<TSearchSchema, TParentSearchSchema>\n  // This function will be called if the route's validateSearch option throws an error **during an attempted validation**.\n  // If you want to redirect due to an error, call `router.navigate()` from within this function.\n  // If you want to display the errorComponent, rethrow the error\n  onValidateSearchError?: (err: any) => void\n  onParseParamsError?: (err: any) => void\n  // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n  loader?: OnLoadFn<\n    TLoader,\n    TSearchSchema,\n    TFullSearchSchema,\n    TAllParams,\n    NoInfer<TRouteContext>,\n    TContext\n  >\n  onLoadError?: (err: any) => void\n  onError?: (err: any) => void\n  // This function is called\n  // when moving from an inactive state to an active one. Likewise, when moving from\n  // an active to an inactive state, the return function (if provided) is called.\n  onLoaded?: (matchContext: {\n    params: TAllParams\n    search: TFullSearchSchema\n  }) =>\n    | void\n    | undefined\n    | ((match: { params: TAllParams; search: TFullSearchSchema }) => void)\n  // This function is called when the route remains active from one transition to the next.\n  onTransition?: (match: {\n    params: TAllParams\n    search: TFullSearchSchema\n  }) => void\n} & MetaOptions &\n  ContextOptions<\n    TParentRoute,\n    TAllParams,\n    TFullSearchSchema,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext\n  > &\n  (\n    | {\n        // Parse params optionally receives path params as strings and returns them in a parsed format (like a number or boolean)\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<ParsePathParams<TPath>, any>\n          ? TParams\n          : 'parseParams must return an object'\n        stringifyParams?: (\n          params: NoInfer<TParams>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  ) &\n  (PickUnsafe<TParentParams, ParsePathParams<TPath>> extends never // Detect if an existing path param is being redefined\n    ? { test?: PickUnsafe<TParentParams, ParsePathParams<TPath>> }\n    : 'Cannot redefined path params in child routes!')\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn, TParentSchema> =\n  | SearchSchemaValidatorObj<TReturn, TParentSchema>\n  | SearchSchemaValidatorFn<TReturn, TParentSchema>\n\nexport type SearchSchemaValidatorObj<TReturn, TParentSchema> = {\n  parse?: SearchSchemaValidatorFn<TReturn, TParentSchema>\n}\n\nexport type SearchSchemaValidatorFn<TReturn, TParentSchema> = (\n  searchObj: Record<string, unknown>,\n) => {} extends TParentSchema\n  ? TReturn\n  : keyof TReturn extends keyof TParentSchema\n  ? {\n      error: 'Top level search params cannot be redefined by child routes!'\n      keys: keyof TReturn & keyof TParentSchema\n    }\n  : TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type OnLoadFn<\n  TLoader = unknown,\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> = (\n  match: LoaderContext<\n    TSearchSchema,\n    TFullSearchSchema,\n    TAllParams,\n    TContext,\n    TAllContext\n  > & {\n    parentMatchPromise?: Promise<void>\n  },\n) => Promise<TLoader> | TLoader\n\nexport type OnLoadFnKey<\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> = (\n  loaderContext: {\n    params: TAllParams\n    search: TFullSearchSchema\n  },\n  // loaderContext: LoaderContext<\n  //   TSearchSchema,\n  //   TFullSearchSchema,\n  //   TAllParams,\n  //   TContext,\n  //   TAllContext\n  // >,\n) => any\n\nexport interface LoaderContext<\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> {\n  params: TAllParams\n  routeSearch: TSearchSchema\n  search: TFullSearchSchema\n  abortController: AbortController\n  preload: boolean\n  routeContext: TContext\n  context: TAllContext\n  // serverOnly: <\n  //   TServer extends object | (() => object),\n  //   TClient extends object | (() => object),\n  // >(\n  //   server: TServer,\n  //   client: TClient,\n  // ) => (TServer extends () => infer TReturn ? TReturn : TServer) &\n  //   (TClient extends () => infer TReturn ? TReturn : TClient)\n}\n\nexport type UnloaderFn<TPath extends string> = (\n  routeMatch: RouteMatch<any, Route>,\n) => void\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\ntype ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  isRoot: true\n  __types: {\n    searchSchema: infer TSearchSchema\n  }\n}\n  ? TSearchSchema\n  : TRoute extends {\n      __types: {\n        fullSearchSchema: infer TFullSearchSchema\n      }\n    }\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> =\n  InferFullSearchSchema<TParentRoute> & TSearchSchema\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\nexport type AnyRouteWithRouterContext<TRouterContext extends AnyContext> =\n  Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    TRouterContext,\n    any,\n    any\n  >\n\ntype MergeFromParent<T, U> = IsAny<T, U, T & U>\n\nexport type UseLoaderResult<T> = T extends Record<PropertyKey, infer U>\n  ? {\n      [K in keyof T]: UseLoaderResultPromise<T[K]>\n    }\n  : UseLoaderResultPromise<T>\n\nexport type UseLoaderResultPromise<T> = T extends Promise<infer U>\n  ? StreamedPromise<U>\n  : T\n\nexport type StreamedPromise<T> = {\n  promise: Promise<T>\n  status: 'resolved' | 'pending'\n  data: T\n  resolve: (value: T) => void\n}\n\nexport class Route<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TPath extends string = '/',\n  TFullPath extends ResolveFullPath<TParentRoute, TPath> = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends string = string,\n  TId extends ResolveId<TParentRoute, TCustomId, TPath> = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TLoader = unknown,\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends Record<ParsePathParams<TPath>, any> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends MergeFromParent<\n    TParentRoute['__types']['allParams'],\n    TParams\n  > = MergeFromParent<TParentRoute['__types']['allParams'], TParams>,\n  TParentContext extends TParentRoute['__types']['routeContext'] = TParentRoute['__types']['routeContext'],\n  TAllParentContext extends TParentRoute['__types']['context'] = TParentRoute['__types']['context'],\n  TRouteContext extends RouteContext = RouteContext,\n  TContext extends MergeFromParent<\n    TParentRoute['__types']['context'],\n    TRouteContext\n  > = MergeFromParent<TParentRoute['__types']['context'], TRouteContext>,\n  TRouterContext extends AnyContext = AnyContext,\n  TChildren extends unknown = unknown,\n  TRoutesInfo extends DefaultRoutesInfo = DefaultRoutesInfo,\n> {\n  __types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    loader: TLoader\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    parentContext: TParentContext\n    allParentContext: TAllParentContext\n    routeContext: TRouteContext\n    context: TContext\n    children: TChildren\n    routesInfo: TRoutesInfo\n    routerContext: TRouterContext\n  }\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TLoader,\n    InferFullSearchSchema<TParentRoute>,\n    TSearchSchema,\n    InferFullSearchSchema<TParentRoute> & TSearchSchema,\n    TParentRoute['__types']['allParams'],\n    TParams,\n    TAllParams,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext,\n    TContext\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: Router<TRoutesInfo['routeTree'], TRoutesInfo>\n  rank!: number\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TLoader,\n      InferFullSearchSchema<TParentRoute>,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentRoute['__types']['allParams'],\n      TParams,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n  }\n\n  init = (opts: { originalIndex: number; router: AnyRouter }) => {\n    this.originalIndex = opts.originalIndex\n    this.router = opts.router\n\n    const allOptions = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TLoader,\n      InferFullSearchSchema<TParentRoute>,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentRoute['__types']['allParams'],\n      TParams,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext\n    > &\n      RouteOptionsBaseIntersection<TCustomId, TPath>\n\n    const isRoot = !allOptions?.path && !allOptions?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : allOptions.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = allOptions?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TLoader,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext,\n    TContext,\n    TRouterContext,\n    TNewChildren,\n    TRoutesInfo\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  useMatch = <TStrict extends boolean = true, TSelected = TContext>(opts?: {\n    strict?: TStrict\n    select?: (search: TContext) => TSelected\n  }): TStrict extends true ? TSelected : TSelected | undefined => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n\n  useLoader = <TStrict extends boolean = true, TSelected = TLoader>(opts?: {\n    strict?: TStrict\n    select?: (search: TLoader) => TSelected\n  }): TStrict extends true\n    ? UseLoaderResult<TSelected>\n    : UseLoaderResult<TSelected> | undefined => {\n    return useLoader({ ...opts, from: this.id }) as any\n  }\n\n  useContext = <TStrict extends boolean = true, TSelected = TContext>(opts?: {\n    strict?: TStrict\n    select?: (search: TContext) => TSelected\n  }): TStrict extends true ? TSelected : TSelected | undefined => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => opts?.select?.(d.context) ?? d.context,\n    } as any)\n  }\n\n  useSearch = <\n    TStrict extends boolean = true,\n    TSelected = TFullSearchSchema,\n  >(opts?: {\n    strict?: TStrict\n    select?: (search: TFullSearchSchema) => TSelected\n  }): TStrict extends true ? TSelected : TSelected | undefined => {\n    return useSearch({ ...opts, from: this.id } as any)\n  }\n\n  useParams = <TStrict extends boolean = true, TSelected = TAllParams>(opts?: {\n    strict?: TStrict\n    select?: (search: TAllParams) => TSelected\n  }): TStrict extends true ? TSelected : TSelected | undefined => {\n    return useParams({ ...opts, from: this.id } as any)\n  }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any>\n\nexport class RouterContext<TRouterContext extends {}> {\n  constructor() {}\n\n  createRootRoute = <\n    TLoader = unknown,\n    TSearchSchema extends AnySearchSchema = {},\n    TContext extends RouteContext = RouteContext,\n  >(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute,\n        RootRouteId,\n        '',\n        TLoader,\n        {},\n        TSearchSchema,\n        NoInfer<TSearchSchema>,\n        {},\n        TRouterContext,\n        TRouterContext,\n        TContext,\n        NoInfer<TContext>\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) => {\n    return new RootRoute<TLoader, TSearchSchema, TContext, TRouterContext>(\n      options,\n    )\n  }\n\n  //   return <\n  //     TLoader = unknown,\n  //     TSearchSchema extends AnySearchSchema = {},\n  //     TContext extends {} = {},\n  //   >(\n  //     options?: Omit<\n  //       RouteOptions<\n  //         AnyRoute,\n  //         RootRouteId,\n  //         '',\n  //         TLoader,\n  //         {},\n  //         TSearchSchema,\n  //         NoInfer<TSearchSchema>,\n  //         {},\n  //         TRouterContext,\n  //         TRouterContext,\n  //         TContext,\n  //         TRouterContext & TContext\n  //       >,\n  //       'path' | 'id' | 'getParentRoute' | 'caseSensitive'\n  //     >,\n  //   ) =>\n  //     new RootRoute<TLoader, TSearchSchema, TContext, TRouterContext>(\n  //       options as any,\n  //     )\n  // }\n}\n\nexport class RootRoute<\n  TLoader = unknown,\n  TSearchSchema extends AnySearchSchema = {},\n  TContext extends RouteContext = RouteContext,\n  TRouterContext extends {} = {},\n> extends Route<\n  any,\n  '/',\n  '/',\n  string,\n  RootRouteId,\n  TLoader,\n  TSearchSchema,\n  TSearchSchema,\n  {},\n  {},\n  TRouterContext,\n  TRouterContext,\n  MergeFromParent<TRouterContext, TContext>,\n  MergeFromParent<TRouterContext, TContext>,\n  TRouterContext,\n  any,\n  any\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute,\n        RootRouteId,\n        '',\n        TLoader,\n        {},\n        TSearchSchema,\n        NoInfer<TSearchSchema>,\n        {},\n        TRouterContext,\n        TRouterContext,\n        TContext,\n        NoInfer<TContext>\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n}\n\ntype ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed extends RoutePrefix<TParentRoute['fullPath'], TPath> = RoutePrefix<\n    TParentRoute['fullPath'],\n    TPath\n  >,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n  ? TPrefix extends RootRouteId\n    ? TPath extends '/'\n      ? '/'\n      : `/${TrimPath<TPath>}`\n    : `${TPrefix}/${TPath}` extends '/'\n    ? '/'\n    : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n  : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n    ? TrimPathLeft<U>\n    : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n  ? TrimPathRight<U>\n  : T\n\n// const rootRoute = new RootRoute({\n//   validateSearch: () => null as unknown as { root?: boolean },\n// })\n\n// const aRoute = new Route({\n//   getParentRoute: () => rootRoute,\n//   path: 'a',\n//   validateSearch: () => null as unknown as { a?: string },\n// })\n\n// const bRoute = new Route({\n//   getParentRoute: () => aRoute,\n//   path: 'b',\n// })\n\n// const rootIsRoot = rootRoute.isRoot\n// //    ^?\n// const aIsRoot = aRoute.isRoot\n// //    ^?\n\n// const rId = rootRoute.id\n// //    ^?\n// const aId = aRoute.id\n// //    ^?\n// const bId = bRoute.id\n// //    ^?\n\n// const rPath = rootRoute.fullPath\n// //    ^?\n// const aPath = aRoute.fullPath\n// //    ^?\n// const bPath = bRoute.fullPath\n// //    ^?\n\n// const rSearch = rootRoute.__types.fullSearchSchema\n// //    ^?\n// const aSearch = aRoute.__types.fullSearchSchema\n// //    ^?\n// const bSearch = bRoute.__types.fullSearchSchema\n// //    ^?\n\n// const config = rootRoute.addChildren([aRoute.addChildren([bRoute])])\n// //    ^?\n", "import { decode, encode } from './qss'\nimport { AnySearchSchema } from './route'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(JSON.stringify)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(stringify: (search: any) => string) {\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else if (val && typeof val === 'object' && val !== null) {\n          try {\n            search[key] = stringify(val)\n          } catch (err) {\n            // silent\n          }\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n", "import { Store } from '@tanstack/react-store'\nimport invariant from 'tiny-invariant'\n\n//\n\nimport {\n  LinkInfo,\n  LinkOptions,\n  NavigateOptions,\n  ToOptions,\n  ResolveRelativePath,\n} from './link'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathRight,\n} from './path'\nimport {\n  Route,\n  AnySearchSchema,\n  AnyRoute,\n  RootRoute,\n  AnyContext,\n  AnyPathParams,\n} from './route'\nimport {\n  RoutesInfo,\n  AnyRoutesInfo,\n  RoutesById,\n  RoutesByPath,\n  DefaultRoutesInfo,\n} from './routeInfo'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  functionalUpdate,\n  last,\n  NoInfer,\n  pick,\n  PickAsRequired,\n  Timeout,\n  Updater,\n  replaceEqualDeep,\n  partialDeepEqual,\n} from './utils'\nimport {\n  createBrowserHistory,\n  createMemoryHistory,\n  RouterHistory,\n} from './history'\nimport { RouteComponent } from './react'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR_DEHYDRATED__?: HydrationCtx\n  }\n\n  interface Error {\n    cause: unknown\n  }\n\n  interface ErrorConstructor {\n    new (reason: string, options?: { cause?: unknown }): Error\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<any, any, any>\n\nexport type RegisteredRouterPair = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? [TRouter, TRouter['types']['RoutesInfo']]\n  : [Router, AnyRoutesInfo]\n\nexport type RegisteredRouter = RegisteredRouterPair[0]\nexport type RegisteredRoutesInfo = RegisteredRouterPair[1]\n\nexport interface LocationState {}\n\nexport interface ParsedLocation<\n  TSearchObj extends AnySearchSchema = {},\n  TState extends LocationState = LocationState,\n> {\n  href: string\n  pathname: string\n  search: TSearchObj\n  searchStr: string\n  state: TState\n  hash: string\n  key?: string\n}\n\nexport interface FromLocation {\n  pathname: string\n  search?: unknown\n  key?: string\n  hash?: string\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport interface RouteMatch<\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TRoute extends AnyRoute = Route,\n> {\n  id: string\n  routeId: string\n  pathname: string\n  params: TRoute['__types']['allParams']\n  status: 'pending' | 'success' | 'error'\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loader: TRoute['__types']['loader']\n  loadPromise?: Promise<void>\n  __resolveLoadPromise?: () => void\n  routeContext: TRoute['__types']['routeContext']\n  context: TRoute['__types']['context']\n  routeSearch: TRoute['__types']['searchSchema']\n  search: TRoutesInfo['fullSearchSchema'] &\n    TRoute['__types']['fullSearchSchema']\n  fetchedAt: number\n  abortController: AbortController\n}\n\nexport type AnyRouteMatch = RouteMatch<AnyRoutesInfo, AnyRoute>\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['__types']['routerContext']\n    ? {\n        context?: TRouteTree['__types']['routerContext']\n      }\n    : {\n        context: TRouteTree['__types']['routerContext']\n      }\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent\n  defaultErrorComponent?: RouteComponent<{\n    error: Error\n    info: { componentStack: string }\n  }>\n  defaultPendingComponent?: RouteComponent\n  defaultLoaderMaxAge?: number\n  defaultLoaderGcMaxAge?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  createRoute?: (opts: { route: AnyRoute; router: AnyRouter }) => void\n  onRouteChange?: () => void\n  // fetchServerDataFn?: FetchServerDataFn\n  context?: TRouteTree['__types']['routerContext']\n  Wrap?: React.ComponentType<{\n    children: React.ReactNode\n    dehydratedState?: TDehydrated\n  }>\n  dehydrate?: () => TDehydrated\n  hydrate?: (dehydrated: TDehydrated) => void\n}\n\nexport interface RouterState<\n  TRoutesInfo extends AnyRoutesInfo = AnyRoutesInfo,\n  TState extends LocationState = LocationState,\n> {\n  status: 'idle' | 'pending'\n  matches: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[]\n  pendingMatches: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[]\n  preloadMatches: Record<\n    string,\n    RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>\n  >\n  location: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  resolvedLocation: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  lastUpdated: number\n}\n\nexport type ListenerFn = () => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: LocationState\n  key?: string\n  from?: string\n  fromCurrent?: boolean\n  __matches?: AnyRouteMatch[]\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n  fromCurrent?: boolean\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nexport interface DehydratedRouterState\n  extends Pick<RouterState, 'status' | 'location' | 'lastUpdated'> {}\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport class Router<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRoutesInfo extends AnyRoutesInfo = RoutesInfo<TRouteTree>,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  types!: {\n    RootRoute: TRouteTree\n    RoutesInfo: TRoutesInfo\n  }\n\n  options: PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  #unsubHistory?: () => void\n  basepath!: string\n  routeTree!: RootRoute\n  routesById!: RoutesById<TRoutesInfo>\n  routesByPath!: RoutesByPath<TRoutesInfo>\n  flatRoutes!: TRoutesInfo['routesByFullPath'][keyof TRoutesInfo['routesByFullPath']][]\n  navigateTimeout: undefined | Timeout\n  nextAction: undefined | 'push' | 'replace'\n  navigationPromise: undefined | Promise<void>\n\n  __store: Store<RouterState<TRoutesInfo>>\n  state: RouterState<TRoutesInfo>\n  startedLoadingAt = Date.now()\n  resolveNavigation: () => void = () => {}\n  dehydratedData?: TDehydrated\n\n  constructor(options: RouterConstructorOptions<TRouteTree, TDehydrated>) {\n    this.options = {\n      defaultPreloadDelay: 50,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n      // fetchServerDataFn: options?.fetchServerDataFn ?? defaultFetchServerDataFn,\n    }\n\n    this.__store = new Store<RouterState<TRoutesInfo>>(\n      getInitialRouterState(),\n      {\n        onUpdate: () => {\n          this.state = this.__store.state\n        },\n        defaultPriority: 'low',\n      },\n    )\n    this.state = this.__store.state\n\n    this.update(options)\n\n    const next = this.buildNext({\n      hash: true,\n      fromCurrent: true,\n      search: true,\n      state: true,\n    })\n\n    if (this.state.location.href !== next.href) {\n      this.#commitLocation({ ...next, replace: true })\n    }\n  }\n\n  reset = () => {\n    this.__store.setState((s) => Object.assign(s, getInitialRouterState()))\n  }\n\n  mount = () => {\n    // If the router matches are empty, start loading the matches\n    if (!this.state.matches.length) {\n      this.safeLoad()\n    }\n  }\n\n  update = (opts?: RouterOptions<any, any>): this => {\n    this.options = {\n      ...this.options,\n      ...opts,\n      context: {\n        ...this.options.context,\n        ...opts?.context,\n      },\n    }\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      if (this.#unsubHistory) {\n        this.#unsubHistory()\n      }\n\n      this.history =\n        this.options.history ??\n        (isServer ? createMemoryHistory() : createBrowserHistory()!)\n\n      const parsedLocation = this.#parseLocation()\n\n      this.__store.setState((s) => ({\n        ...s,\n        resolvedLocation: parsedLocation,\n        location: parsedLocation,\n      }))\n\n      this.#unsubHistory = this.history.listen(() => {\n        this.safeLoad({\n          next: this.#parseLocation(this.state.location),\n        })\n      })\n    }\n\n    const { basepath, routeTree } = this.options\n\n    this.basepath = `/${trimPath(basepath ?? '') ?? ''}`\n\n    if (routeTree && routeTree !== this.routeTree) {\n      this.#buildRouteTree(routeTree)\n    }\n\n    return this\n  }\n\n  buildNext = (opts: BuildNextOptions): ParsedLocation => {\n    const next = this.#buildLocation(opts)\n\n    const __matches = this.matchRoutes(next.pathname, next.search)\n\n    return this.#buildLocation({\n      ...opts,\n      __matches,\n    })\n  }\n\n  cancelMatches = () => {\n    this.state.matches.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  cancelMatch = (id: string) => {\n    this.getRouteMatch(id)?.abortController?.abort()\n  }\n\n  safeLoad = (opts?: { next?: ParsedLocation }) => {\n    this.load(opts).catch((err) => {\n      // console.warn(err)\n      // invariant(false, 'Encountered an error during router.load()! ☝️.')\n    })\n  }\n\n  load = async (opts?: { next?: ParsedLocation }): Promise<void> => {\n    this.#createNavigationPromise()\n\n    let now = Date.now()\n    const startedAt = now\n    this.startedLoadingAt = startedAt\n\n    // Cancel any pending matches\n    this.cancelMatches()\n\n    let pendingMatches!: RouteMatch<any, any>[]\n\n    this.__store.batch(() => {\n      if (opts?.next) {\n        // Ingest the new location\n        this.__store.setState((s) => ({\n          ...s,\n          location: opts.next!,\n        }))\n      }\n\n      // Match the routes\n      pendingMatches = this.matchRoutes(\n        this.state.location.pathname,\n        this.state.location.search,\n        {\n          // throwOnError: true,\n        },\n      )\n\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'pending',\n        pendingMatches,\n      }))\n    })\n\n    // Load the matches\n    await this.loadMatches(pendingMatches)\n\n    if (this.startedLoadingAt !== startedAt) {\n      // Ignore side-effects of outdated side-effects\n      return this.navigationPromise\n    }\n\n    const prevLocation = this.state.resolvedLocation\n\n    this.__store.setState((s) => ({\n      ...s,\n      status: 'idle',\n      resolvedLocation: s.location,\n      matches: s.pendingMatches,\n      pendingMatches: [],\n    }))\n\n    if (prevLocation!.href !== this.state.location.href) {\n      this.options.onRouteChange?.()\n    }\n\n    this.resolveNavigation()\n  }\n\n  getRoute = <TId extends keyof TRoutesInfo['routesById']>(\n    id: TId,\n  ): TRoutesInfo['routesById'][TId] => {\n    const route = this.routesById[id]\n\n    invariant(route, `Route with id \"${id as string}\" not found`)\n\n    return route\n  }\n\n  preloadRoute = async (\n    navigateOpts: BuildNextOptions = this.state.location,\n  ) => {\n    const next = this.buildNext(navigateOpts)\n    const matches = this.matchRoutes(next.pathname, next.search, {\n      throwOnError: true,\n    })\n\n    const matchesById: any = {}\n\n    matches.forEach((m) => {\n      if (!this.state.matches.find((d) => d.id === m.id)) {\n        matchesById[m.id] = m\n      }\n    })\n\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        preloadMatches: {\n          ...s.preloadMatches,\n          ...matchesById,\n        },\n      }\n    })\n\n    await this.loadMatches(matches, {\n      preload: true,\n    })\n    return matches\n  }\n\n  matchRoutes = (\n    pathname: string,\n    locationSearch: AnySearchSchema,\n    opts?: { throwOnError?: boolean },\n  ): RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[] => {\n    let routeParams: AnyPathParams = {}\n\n    let foundRoute = this.flatRoutes.find((route) => {\n      const matchedParams = matchPathname(this.basepath, pathname, {\n        to: route.fullPath,\n        caseSensitive:\n          route.options.caseSensitive ?? this.options.caseSensitive,\n      })\n\n      if (matchedParams) {\n        routeParams = matchedParams\n        return true\n      }\n\n      return false\n    })\n\n    let routeCursor = foundRoute || (this.routesById['__root__'] as any)\n\n    let matchedRoutes: AnyRoute[] = [routeCursor]\n\n    while (routeCursor?.parentRoute) {\n      routeCursor = routeCursor.parentRoute\n      if (routeCursor) matchedRoutes.unshift(routeCursor)\n    }\n\n    // Alright, by now we should have all of our\n    // matching routes and their param pairs, let's\n    // Turn them into actual `Match` objects and\n    // accumulate the params into a single params bag\n    let allParams = {}\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n\n    const matches = matchedRoutes.map((route) => {\n      let parsedParams\n      let parsedParamsError\n\n      try {\n        parsedParams = route.options.parseParams?.(routeParams!) ?? routeParams\n      } catch (err: any) {\n        parsedParamsError = new PathParamError(err.message, {\n          cause: err,\n        })\n\n        if (opts?.throwOnError) {\n          throw parsedParamsError\n        }\n      }\n\n      // Add the parsed params to the accumulated params bag\n      Object.assign(allParams, parsedParams)\n\n      const interpolatedPath = interpolatePath(route.path, allParams)\n      const matchId =\n        interpolatePath(route.id, allParams, true) +\n        (route.options.getKey?.({\n          params: allParams,\n          search: locationSearch,\n        }) ?? '')\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      const existingMatch = this.getRouteMatch(matchId)\n\n      if (existingMatch) {\n        // Return a copy, we don't want to mutate the existing match\n        return { ...existingMatch }\n      }\n\n      // Create a fresh route match\n      const hasLoaders = !!(\n        route.options.loader ||\n        componentTypes.some((d) => route.options[d]?.preload)\n      )\n\n      const routeMatch: RouteMatch = {\n        id: matchId,\n        routeId: route.id,\n        params: allParams,\n        pathname: joinPaths([this.basepath, interpolatedPath]),\n        updatedAt: 0,\n        routeSearch: {},\n        search: {} as any,\n        status: hasLoaders ? 'pending' : 'success',\n        error: undefined,\n        paramsError: parsedParamsError,\n        searchError: undefined,\n        loader: undefined,\n        loadPromise: Promise.resolve(),\n        routeContext: undefined!,\n        context: undefined!,\n        abortController: new AbortController(),\n        fetchedAt: 0,\n      }\n\n      return routeMatch\n    })\n\n    // Take each match and resolve its search params and context\n    // This has to happen after the matches are created or found\n    // so that we can use the parent match's search params and context\n    matches.forEach((match, i): any => {\n      const parentMatch = matches[i - 1]\n      const route = this.getRoute(match.routeId)\n\n      const searchInfo = (() => {\n        // Validate the search params and stabilize them\n        const parentSearchInfo = {\n          search: parentMatch?.search ?? locationSearch,\n          routeSearch: parentMatch?.routeSearch ?? locationSearch,\n        }\n\n        try {\n          const validator =\n            typeof route.options.validateSearch === 'object'\n              ? route.options.validateSearch.parse\n              : route.options.validateSearch\n\n          const routeSearch = validator?.(parentSearchInfo.search) ?? {}\n\n          const search = {\n            ...parentSearchInfo.search,\n            ...routeSearch,\n          }\n\n          return {\n            routeSearch: replaceEqualDeep(match.routeSearch, routeSearch),\n            search: replaceEqualDeep(match.search, search),\n          }\n        } catch (err: any) {\n          match.searchError = new SearchParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw match.searchError\n          }\n\n          return parentSearchInfo\n        }\n      })()\n\n      const contextInfo = (() => {\n        try {\n          const routeContext =\n            route.options.getContext?.({\n              parentContext: parentMatch?.routeContext ?? {},\n              context: parentMatch?.context ?? this?.options.context ?? {},\n              params: match.params,\n              search: match.search,\n            }) || ({} as any)\n\n          const context = {\n            ...(parentMatch?.context ?? this?.options.context),\n            ...routeContext,\n          } as any\n\n          return {\n            context,\n            routeContext,\n          }\n        } catch (err) {\n          route.options.onError?.(err)\n          throw err\n        }\n      })()\n\n      Object.assign(match, {\n        ...searchInfo,\n        ...contextInfo,\n      })\n    })\n\n    return matches\n  }\n\n  loadMatches = async (\n    resolvedMatches: AnyRouteMatch[],\n    opts?: {\n      preload?: boolean\n    },\n  ) => {\n    let firstBadMatchIndex: number | undefined\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      await Promise.all(\n        resolvedMatches.map(async (match, index) => {\n          const route = this.getRoute(match.routeId)\n\n          const handleError = (\n            err: any,\n            handler: undefined | ((err: any) => void),\n          ) => {\n            firstBadMatchIndex = firstBadMatchIndex ?? index\n            handler = handler || route.options.onError\n\n            if (isRedirect(err)) {\n              throw err\n            }\n\n            try {\n              handler?.(err)\n            } catch (errorHandlerErr) {\n              err = errorHandlerErr\n\n              if (isRedirect(errorHandlerErr)) {\n                throw errorHandlerErr\n              }\n            }\n\n            this.setRouteMatch(match.id, (s) => ({\n              ...s,\n              error: err,\n              status: 'error',\n              updatedAt: Date.now(),\n            }))\n          }\n\n          if (match.paramsError) {\n            handleError(match.paramsError, route.options.onParseParamsError)\n          }\n\n          if (match.searchError) {\n            handleError(match.searchError, route.options.onValidateSearchError)\n          }\n\n          try {\n            await route.options.beforeLoad?.({\n              router: this as any,\n              match,\n            })\n          } catch (err) {\n            handleError(err, route.options.onBeforeLoadError)\n          }\n        }),\n      )\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!opts?.preload) {\n          this.navigate(err as any)\n        }\n        return\n      }\n\n      throw err // we should never end up here\n    }\n\n    const validResolvedMatches = resolvedMatches.slice(0, firstBadMatchIndex)\n    const matchPromises: Promise<any>[] = []\n\n    validResolvedMatches.forEach((match, index) => {\n      matchPromises.push(\n        Promise.resolve().then(async () => {\n          const parentMatchPromise = matchPromises[index - 1]\n          const route = this.getRoute(match.routeId)\n          const fetchedAt = Date.now()\n          const loadPromise = Promise.resolve().then(async () => {\n            const checkLatest = () => {\n              const latest = this.getRouteMatch(match.id)\n              return latest && latest.fetchedAt !== fetchedAt\n                ? latest.loadPromise\n                : undefined\n            }\n\n            let latestPromise\n\n            const componentsPromise = (async () => {\n              // then run all component and data loaders in parallel\n              // For each component type, potentially load it asynchronously\n\n              await Promise.all(\n                componentTypes.map(async (type) => {\n                  const component = route.options[type]\n\n                  if (component?.preload) {\n                    await component.preload()\n                  }\n                }),\n              )\n            })()\n\n            const loaderPromise = Promise.resolve().then(() => {\n              if (route.options.loader) {\n                return route.options.loader({\n                  ...match,\n                  preload: !!opts?.preload,\n                  parentMatchPromise,\n                })\n              }\n              return\n            })\n\n            try {\n              const [_, loader] = await Promise.all([\n                componentsPromise,\n                loaderPromise,\n              ])\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              if (\n                !opts?.preload ||\n                !this.state.matches.find((d) => d.id === match.id)\n              ) {\n                this.setRouteMatch(match.id, (s) => ({\n                  ...s,\n                  error: undefined,\n                  status: 'success',\n                  updatedAt: Date.now(),\n                  loader,\n                }))\n              }\n            } catch (err) {\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              if (isRedirect(err)) {\n                if (!opts?.preload) {\n                  this.navigate(err as any)\n                }\n                return\n              }\n\n              const errorHandler =\n                route.options.onLoadError ?? route.options.onError\n\n              let caughtError = err\n\n              try {\n                errorHandler?.(err)\n              } catch (errorHandlerErr) {\n                caughtError = errorHandlerErr\n                if (isRedirect(errorHandlerErr)) {\n                  if (!opts?.preload) {\n                    this.navigate(errorHandlerErr as any)\n                  }\n                  return\n                }\n              }\n\n              this.setRouteMatch(match.id, (s) => ({\n                ...s,\n                error: caughtError,\n                status: 'error',\n                updatedAt: Date.now(),\n              }))\n            } finally {\n              if ((latestPromise = checkLatest())) return await latestPromise\n              if (opts?.preload) {\n                this.__store.setState((s) => {\n                  const preloadMatches = { ...s.preloadMatches }\n                  delete preloadMatches[match.id]\n                  return {\n                    ...s,\n                    preloadMatches,\n                  }\n                })\n              }\n            }\n          })\n\n          this.setRouteMatch(match.id, (s) => ({\n            ...s,\n            loadPromise,\n            fetchedAt,\n          }))\n\n          await loadPromise\n        }),\n      )\n    })\n\n    await Promise.all(matchPromises)\n  }\n\n  reload = () => {\n    this.navigate({\n      fromCurrent: true,\n      replace: true,\n      search: true,\n    } as any)\n  }\n\n  resolvePath = (from: string, path: string) => {\n    return resolvePath(this.basepath!, from, cleanPath(path))\n  }\n\n  navigate = async <TFrom extends string = '/', TTo extends string = ''>({\n    from,\n    to = '' as any,\n    search,\n    hash,\n    replace,\n    params,\n  }: NavigateOptions<TRoutesInfo, TFrom, TTo>) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    const fromString = typeof from === 'undefined' ? from : String(from)\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.#commitLocation({\n      from: fromString,\n      to: toString,\n      search,\n      hash,\n      replace,\n      params,\n    })\n  }\n\n  matchRoute = <\n    TFrom extends string = '/',\n    TTo extends string = '',\n    TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  >(\n    location: ToOptions<TRoutesInfo, TFrom, TTo>,\n    opts?: MatchRouteOptions,\n  ): false | TRoutesInfo['routesById'][TResolved]['__types']['allParams'] => {\n    location = {\n      ...location,\n      to: location.to\n        ? this.resolvePath(location.from ?? '', location.to)\n        : undefined,\n    } as any\n\n    const next = this.buildNext(location)\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const baseLocation = opts?.pending\n      ? this.state.location\n      : this.state.resolvedLocation\n\n    if (!baseLocation) {\n      return false\n    }\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n\n    if (opts?.includeSearch ?? true) {\n      return partialDeepEqual(baseLocation.search, next.search) ? match : false\n    }\n\n    return match\n  }\n\n  buildLink = <TFrom extends string = '/', TTo extends string = ''>({\n    from,\n    to = '.' as any,\n    search,\n    params,\n    hash,\n    target,\n    replace,\n    activeOptions,\n    preload,\n    preloadDelay: userPreloadDelay,\n    disabled,\n  }: LinkOptions<TRoutesInfo, TFrom, TTo>): LinkInfo => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    try {\n      new URL(`${to}`)\n      return {\n        type: 'external',\n        href: to,\n      }\n    } catch (e) {}\n\n    const nextOpts = {\n      from,\n      to,\n      search,\n      params,\n      hash,\n      replace,\n    }\n\n    const next = this.buildNext(nextOpts)\n\n    preload = preload ?? this.options.defaultPreload\n    const preloadDelay =\n      userPreloadDelay ?? this.options.defaultPreloadDelay ?? 0\n\n    // Compare path/hash for matches\n    const currentPathSplit = this.state.location.pathname.split('/')\n    const nextPathSplit = next.pathname.split('/')\n    const pathIsFuzzyEqual = nextPathSplit.every(\n      (d, i) => d === currentPathSplit[i],\n    )\n    // Combine the matches based on user options\n    const pathTest = activeOptions?.exact\n      ? this.state.location.pathname === next.pathname\n      : pathIsFuzzyEqual\n    const hashTest = activeOptions?.includeHash\n      ? this.state.location.hash === next.hash\n      : true\n    const searchTest =\n      activeOptions?.includeSearch ?? true\n        ? partialDeepEqual(this.state.location.search, next.search)\n        : true\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest && searchTest\n\n    // The click handler\n    const handleClick = (e: MouseEvent) => {\n      if (\n        !disabled &&\n        !isCtrlEvent(e) &&\n        !e.defaultPrevented &&\n        (!target || target === '_self') &&\n        e.button === 0\n      ) {\n        e.preventDefault()\n\n        // All is well? Navigate!\n        this.#commitLocation(nextOpts as any)\n      }\n    }\n\n    // The click handler\n    const handleFocus = (e: MouseEvent) => {\n      if (preload) {\n        this.preloadRoute(nextOpts).catch((err) => {\n          console.warn(err)\n          console.warn('Error preloading route! ☝️')\n        })\n      }\n    }\n\n    const handleTouchStart = (e: TouchEvent) => {\n      this.preloadRoute(nextOpts).catch((err) => {\n        console.warn(err)\n        console.warn('Error preloading route! ☝️')\n      })\n    }\n\n    const handleEnter = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (preload) {\n        if (target.preloadTimeout) {\n          return\n        }\n\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null\n          this.preloadRoute(nextOpts).catch((err) => {\n            console.warn(err)\n            console.warn('Error preloading route! ☝️')\n          })\n        }, preloadDelay)\n      }\n    }\n\n    const handleLeave = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout)\n        target.preloadTimeout = null\n      }\n    }\n\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      handleTouchStart,\n      isActive,\n      disabled,\n    }\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    return {\n      state: pick(this.state, ['location', 'status', 'lastUpdated']),\n    }\n  }\n\n  hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {\n    let _ctx = __do_not_use_server_ctx\n    // Client hydrates from window\n    if (typeof document !== 'undefined') {\n      _ctx = window.__TSR_DEHYDRATED__\n    }\n\n    invariant(\n      _ctx,\n      'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n    )\n\n    const ctx = _ctx\n    this.dehydratedData = ctx.payload as any\n    this.options.hydrate?.(ctx.payload as any)\n\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        ...ctx.router.state,\n        matches: s.matches,\n        resolvedLocation: ctx.router.state.location,\n      }\n    })\n\n    await this.load()\n\n    return\n  }\n\n  injectedHtml: (string | (() => Promise<string> | string))[] = []\n\n  injectHtml = async (html: string | (() => Promise<string> | string)) => {\n    this.injectedHtml.push(html)\n  }\n\n  dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n    if (typeof document === 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      this.injectHtml(async () => {\n        const id = `__TSR_DEHYDRATED__${strKey}`\n        const data =\n          typeof getData === 'function' ? await (getData as any)() : getData\n        return `<script id='${id}' suppressHydrationWarning>window[\"__TSR_DEHYDRATED__${escapeJSON(\n          strKey,\n        )}\"] = ${JSON.stringify(data)}\n        ;(() => {\n          var el = document.getElementById('${id}')\n          el.parentElement.removeChild(el)\n        })()\n        </script>`\n      })\n\n      return () => this.hydrateData<T>(key)\n    }\n\n    return () => undefined\n  }\n\n  hydrateData = <T = unknown>(key: any) => {\n    if (typeof document !== 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      return window[`__TSR_DEHYDRATED__${strKey}` as any] as T\n    }\n\n    return undefined\n  }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   this.state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n\n  #buildRouteTree = (routeTree: TRouteTree) => {\n    this.routeTree = routeTree as any\n    this.routesById = {} as any\n    this.routesByPath = {} as any\n    this.flatRoutes = [] as any\n\n    const recurseRoutes = (routes: AnyRoute[]) => {\n      routes.forEach((route, i) => {\n        route.init({ originalIndex: i, router: this })\n\n        const existingRoute = (this.routesById as any)[route.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(route.id)}`,\n        )\n        ;(this.routesById as any)[route.id] = route\n\n        if (!route.isRoot && route.path) {\n          const trimmedFullPath = trimPathRight(route.fullPath)\n          if (\n            !this.routesByPath[trimmedFullPath] ||\n            route.fullPath.endsWith('/')\n          ) {\n            ;(this.routesByPath as any)[trimmedFullPath] = route\n          }\n        }\n\n        const children = route.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([routeTree])\n\n    this.flatRoutes = (Object.values(this.routesByPath) as AnyRoute[])\n      .map((d, i) => {\n        const trimmed = trimPath(d.fullPath)\n        const parsed = parsePathname(trimmed)\n\n        while (parsed.length > 1 && parsed[0]?.value === '/') {\n          parsed.shift()\n        }\n\n        const score = parsed.map((d) => {\n          if (d.type === 'param') {\n            return 0.5\n          }\n\n          if (d.type === 'wildcard') {\n            return 0.25\n          }\n\n          return 1\n        })\n\n        return { child: d, trimmed, parsed, index: i, score }\n      })\n      .sort((a, b) => {\n        let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0\n\n        if (isIndex !== 0) return isIndex\n\n        const length = Math.min(a.score.length, b.score.length)\n\n        // Sort by length of score\n        if (a.score.length !== b.score.length) {\n          return b.score.length - a.score.length\n        }\n\n        // Sort by min available score\n        for (let i = 0; i < length; i++) {\n          if (a.score[i] !== b.score[i]) {\n            return b.score[i]! - a.score[i]!\n          }\n        }\n\n        // Sort by min available parsed value\n        for (let i = 0; i < length; i++) {\n          if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n            return a.parsed[i]!.value! > b.parsed[i]!.value! ? 1 : -1\n          }\n        }\n\n        // Sort by length of trimmed full path\n        if (a.trimmed !== b.trimmed) {\n          return a.trimmed > b.trimmed ? 1 : -1\n        }\n\n        // Sort by original index\n        return a.index - b.index\n      })\n      .map((d, i) => {\n        d.child.rank = i\n        return d.child\n      }) as any\n  }\n\n  #parseLocation = (previousLocation?: ParsedLocation): ParsedLocation => {\n    let { pathname, search, hash, state } = this.history.location\n\n    const parsedSearch = this.options.parseSearch(search)\n\n    return {\n      pathname: pathname,\n      searchStr: search,\n      search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n      hash: hash.split('#').reverse()[0] ?? '',\n      href: `${pathname}${search}${hash}`,\n      state: state as LocationState,\n      key: state?.key || '__init__',\n    }\n  }\n\n  #buildLocation = (dest: BuildNextOptions = {}): ParsedLocation => {\n    dest.fromCurrent = dest.fromCurrent ?? dest.to === ''\n\n    const fromPathname = dest.fromCurrent\n      ? this.state.location.pathname\n      : dest.from ?? this.state.location.pathname\n\n    let pathname = resolvePath(\n      this.basepath ?? '/',\n      fromPathname,\n      `${dest.to ?? ''}`,\n    )\n\n    const fromMatches = this.matchRoutes(\n      this.state.location.pathname,\n      this.state.location.search,\n    )\n\n    const prevParams = { ...last(fromMatches)?.params }\n\n    let nextParams =\n      (dest.params ?? true) === true\n        ? prevParams\n        : functionalUpdate(dest.params!, prevParams)\n\n    if (nextParams) {\n      dest.__matches\n        ?.map((d) => this.getRoute(d.routeId).options.stringifyParams)\n        .filter(Boolean)\n        .forEach((fn) => {\n          nextParams = { ...nextParams!, ...fn!(nextParams!) }\n        })\n    }\n\n    pathname = interpolatePath(pathname, nextParams ?? {})\n\n    const preSearchFilters =\n      dest.__matches\n        ?.map(\n          (match) =>\n            this.getRoute(match.routeId).options.preSearchFilters ?? [],\n        )\n        .flat()\n        .filter(Boolean) ?? []\n\n    const postSearchFilters =\n      dest.__matches\n        ?.map(\n          (match) =>\n            this.getRoute(match.routeId).options.postSearchFilters ?? [],\n        )\n        .flat()\n        .filter(Boolean) ?? []\n\n    // Pre filters first\n    const preFilteredSearch = preSearchFilters?.length\n      ? preSearchFilters?.reduce(\n          (prev, next) => next(prev),\n          this.state.location.search,\n        )\n      : this.state.location.search\n\n    // Then the link/navigate function\n    const destSearch =\n      dest.search === true\n        ? preFilteredSearch // Preserve resolvedFrom true\n        : dest.search\n        ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n        : preSearchFilters?.length\n        ? preFilteredSearch // Preserve resolvedFrom filters\n        : {}\n\n    // Then post filters\n    const postFilteredSearch = postSearchFilters?.length\n      ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n      : destSearch\n\n    const search = replaceEqualDeep(\n      this.state.location.search,\n      postFilteredSearch,\n    )\n\n    const searchStr = this.options.stringifySearch(search)\n\n    const hash =\n      dest.hash === true\n        ? this.state.location.hash\n        : functionalUpdate(dest.hash!, this.state.location.hash)\n\n    const hashStr = hash ? `#${hash}` : ''\n\n    const nextState =\n      dest.state === true\n        ? this.state.location.state\n        : functionalUpdate(dest.state, this.state.location.state)!\n\n    return {\n      pathname,\n      search,\n      searchStr,\n      state: nextState,\n      hash,\n      href: this.history.createHref(`${pathname}${searchStr}${hashStr}`),\n      key: dest.key,\n    }\n  }\n\n  #commitLocation = async (\n    location: BuildNextOptions & { replace?: boolean },\n  ) => {\n    const next = this.buildNext(location)\n    const id = '' + Date.now() + Math.random()\n\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    let nextAction: 'push' | 'replace' = 'replace'\n\n    if (!location.replace) {\n      nextAction = 'push'\n    }\n\n    const isSameUrl = this.state.location.href === next.href\n\n    if (isSameUrl && !next.key) {\n      nextAction = 'replace'\n    }\n\n    const href = `${next.pathname}${next.searchStr}${\n      next.hash ? `#${next.hash}` : ''\n    }`\n\n    this.history[nextAction === 'push' ? 'push' : 'replace'](href, {\n      id,\n      ...next.state,\n    })\n\n    return this.#createNavigationPromise()\n  }\n\n  #createNavigationPromise = () => {\n    const previousNavigationResolve = this.resolveNavigation\n\n    this.navigationPromise = new Promise((resolve) => {\n      this.resolveNavigation = () => {\n        resolve()\n        previousNavigationResolve()\n      }\n    })\n\n    return this.navigationPromise\n  }\n\n  getRouteMatch = (\n    id: string,\n  ): undefined | RouteMatch<TRoutesInfo, AnyRoute> => {\n    return (\n      this.state.matches.find((d) => d.id === id) ||\n      this.state.preloadMatches[id]\n    )\n  }\n\n  #setResolvedRouteMatch = (\n    id: string,\n    updater: (\n      prev: RouteMatch<TRoutesInfo, AnyRoute>,\n    ) => RouteMatch<TRoutesInfo, AnyRoute>,\n  ) => {\n    this.__store.setState((prev) => ({\n      ...prev,\n      matches: prev.matches.map((d) => {\n        if (d.id === id) {\n          return updater(d as any)\n        }\n        return d\n      }),\n    }))\n  }\n\n  #setPendingRouteMatch = (\n    id: string,\n    updater: (\n      prev: RouteMatch<TRoutesInfo, AnyRoute>,\n    ) => RouteMatch<TRoutesInfo, AnyRoute>,\n  ) => {\n    this.__store.setState((prev) => ({\n      ...prev,\n      pendingMatches: prev.pendingMatches.map((d) => {\n        if (d.id === id) {\n          return updater(d as any)\n        }\n        return d\n      }),\n    }))\n  }\n\n  #setPreloadRouteMatch = (\n    id: string,\n    updater: (\n      prev: RouteMatch<TRoutesInfo, AnyRoute>,\n    ) => RouteMatch<TRoutesInfo, AnyRoute>,\n  ) => {\n    invariant(this.state.preloadMatches[id], 'Match not found')\n\n    this.__store.setState((prev) => ({\n      ...prev,\n      preloadMatches: {\n        ...prev.preloadMatches,\n        [id]: updater(prev.preloadMatches[id] as any),\n      },\n    }))\n  }\n\n  setRouteMatch = (\n    id: string,\n    updater: (\n      prev: RouteMatch<TRoutesInfo, AnyRoute>,\n    ) => RouteMatch<TRoutesInfo, AnyRoute>,\n  ) => {\n    if (this.state.matches.find((d) => d.id === id)) {\n      return this.#setResolvedRouteMatch(id, updater)\n    }\n\n    if (this.state.pendingMatches.find((d) => d.id === id)) {\n      return this.#setPendingRouteMatch(id, updater)\n    }\n\n    if (this.state.preloadMatches[id]) {\n      return this.#setPreloadRouteMatch(id, updater)\n    }\n  }\n}\n\n// Detect if we're in the DOM\nconst isServer = typeof window === 'undefined' || !window.document.createElement\n\nfunction getInitialRouterState(): RouterState<any, any> {\n  return {\n    status: 'idle',\n    resolvedLocation: null!,\n    location: null!,\n    matches: [],\n    pendingMatches: [],\n    preloadMatches: {},\n    lastUpdated: Date.now(),\n  }\n}\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nexport type AnyRedirect = Redirect<any, any, any>\n\nexport type Redirect<\n  TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo,\n  TFrom extends TRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = NavigateOptions<TRoutesInfo, TFrom, TTo> & {\n  code?: number\n}\n\nexport function redirect<\n  TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo,\n  TFrom extends TRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n>(opts: Redirect<TRoutesInfo, TFrom, TTo>): Redirect<TRoutesInfo, TFrom, TTo> {\n  ;(opts as any).isRedirect = true\n  return opts\n}\n\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return !!obj?.isRedirect\n}\n\nexport class SearchParamError extends Error {}\nexport class PathParamError extends Error {}\n\nfunction escapeJSON(jsonString: string) {\n  return jsonString\n    .replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n    .replace(/'/g, \"\\\\'\") // Escape single quotes\n    .replace(/\"/g, '\\\\\"') // Escape double quotes\n}\n"],
  "mappings": "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",
  "names": ["Store", "constructor", "initialState", "options", "listeners", "Set", "_batching", "_flushing", "_nextPriority", "subscribe", "listener", "add", "unsub", "onSubscribe", "delete", "setState", "updater", "opts", "previous", "state", "updateFn", "priority", "defaultPriority", "onUpdate", "_flush", "flushId", "forEach", "batch", "cb", "useStore", "store", "selector", "d", "slice", "useSyncExternalStoreWithSelector", "subscribe", "state", "shallow", "objA", "objB", "Object", "is", "keysA", "keys", "length", "i", "prototype", "hasOwnProperty", "call", "popStateEvent", "beforeUnloadEvent", "beforeUnloadListener", "event", "preventDefault", "returnValue", "stopBlocking", "removeEventListener", "capture", "createHistory", "opts", "location", "getLocation", "unsub", "listeners", "Set", "blockers", "queue", "tryFlush", "length", "shift", "onUpdate", "queueTask", "task", "push", "forEach", "listener", "listen", "cb", "size", "add", "delete", "path", "state", "pushState", "replace", "replaceState", "go", "index", "back", "forward", "createHref", "str", "block", "addEventListener", "filter", "b", "createBrowserHistory", "getHref", "window", "pathname", "search", "hash", "parseLocation", "history", "key", "createRandomKey", "n", "createHashHistory", "substring", "createMemoryHistory", "initialEntries", "entries", "initialIndex", "currentState", "Math", "min", "href", "hashIndex", "indexOf", "searchIndex", "slice", "undefined", "random", "toString", "last", "arr", "isFunction", "d", "functionalUpdate", "updater", "previous", "pick", "parent", "keys", "reduce", "obj", "replaceEqualDeep", "prev", "_next", "next", "array", "Array", "isArray", "isPlainObject", "prevSize", "Object", "nextItems", "nextSize", "copy", "equalItems", "i", "o", "hasObjectPrototype", "ctor", "constructor", "prot", "prototype", "hasOwnProperty", "call", "partialDeepEqual", "a", "some", "every", "item", "joinPaths", "paths", "cleanPath", "Boolean", "join", "trimPathLeft", "trimPathRight", "trimPath", "resolvePath", "basepath", "base", "to", "RegExp", "baseSegments", "parsePathname", "toSegments", "toSegment", "value", "pop", "joined", "map", "segments", "type", "split", "part", "charAt", "interpolatePath", "params", "leaveWildcards", "interpolatedPathSegments", "segment", "matchPathname", "currentPathname", "matchLocation", "pathParams", "matchByPath", "from", "routeSegments", "startsWith", "unshift", "isMatch", "max", "baseSegment", "routeSegment", "isLastBaseSegment", "isLastRouteSegment", "caseSensitive", "toLowerCase", "fuzzy", "encode", "pfx", "k", "tmp", "encodeURIComponent", "toValue", "mix", "decodeURIComponent", "decode", "out", "concat", "lazy", "importer", "exportName", "lazyComp", "moduleExports", "component", "default", "finalComp", "preload", "useLinkProps", "options", "router", "useRouter", "children", "target", "activeProps", "className", "inactiveProps", "activeOptions", "disabled", "preloadDelay", "style", "onClick", "onFocus", "onMouseEnter", "onMouseLeave", "onTouchStart", "rest", "linkInfo", "buildLink", "handleClick", "handleFocus", "handleEnter", "handleLeave", "handleTouchStart", "isActive", "handleReactClick", "e", "startTransition", "composeHandlers", "handlers", "persist", "handler", "defaultPrevented", "resolvedActiveProps", "resolvedInactiveProps", "role", "Link", "forwardRef", "props", "ref", "linkProps", "Navigate", "React", "useLayoutEffect", "navigate", "matchIdsContext", "createContext", "routerContext", "useRouterState", "useStore", "__store", "select", "RouterProvider", "update", "useEffect", "mount", "Wrap", "Fragment", "Matches", "matchIds", "matches", "id", "ErrorComponent", "warning", "useContext", "useMatches", "findIndex", "useMatch", "nearestMatchId", "nearestMatchRouteId", "getRouteMatch", "routeId", "matchRouteId", "match", "find", "strict", "invariant", "useLoader", "loader", "useSearch", "useParams", "useNavigate", "defaultOpts", "useCallback", "useMatchRoute", "pending", "matchRoute", "MatchRoute", "Outlet", "defaultPending", "Match", "matchId", "route", "getRoute", "PendingComponent", "pendingComponent", "defaultPendingComponent", "errorComponent", "defaultErrorComponent", "ResolvedSuspenseBoundary", "wrapInSuspense", "isRoot", "Suspense", "SafeFragment", "ResolvedCatchBoundary", "CatchBoundary", "MatchInner", "status", "error", "comp", "defaultComponent", "createElement", "useInjectHtml", "html", "injectHtml", "useDehydrate", "dehydrate", "data", "dehydrateData", "useHydrate", "hydrate", "hydrateData", "Component", "info", "componentDidCatch", "onCatch", "setState", "render", "CatchBoundaryInner", "locationKey", "resolvedLocation", "activeErrorState", "setActiveErrorState", "useState", "errorState", "prevKeyRef", "useRef", "current", "padding", "maxWidth", "fontSize", "height", "border", "borderRadius", "color", "overflow", "message", "useBlocker", "condition", "unblock", "retry", "cancel", "confirm", "Block", "shallow", "objA", "objB", "is", "keysA", "rootRouteId", "Route", "init", "originalIndex", "allOptions", "parentRoute", "getParentRoute", "customId", "fullPath", "addChildren", "context", "RouterContext", "createRootRoute", "RootRoute", "defaultParseSearch", "parseSearchWith", "JSON", "parse", "defaultStringifySearch", "stringifySearchWith", "stringify", "parser", "searchStr", "query", "err", "val", "componentTypes", "Router", "startedLoadingAt", "Date", "now", "resolveNavigation", "reset", "s", "assign", "getInitialRouterState", "safeLoad", "isServer", "parsedLocation", "routeTree", "buildNext", "__matches", "matchRoutes", "cancelMatches", "cancelMatch", "abortController", "abort", "load", "catch", "startedAt", "pendingMatches", "batch", "loadMatches", "navigationPromise", "prevLocation", "onRouteChange", "routesById", "preloadRoute", "navigateOpts", "throwOnError", "matchesById", "m", "preloadMatches", "locationSearch", "routeParams", "foundRoute", "flatRoutes", "matchedParams", "routeCursor", "matchedRoutes", "allParams", "parsedParams", "parsedParamsError", "parseParams", "PathParamError", "cause", "interpolatedPath", "getKey", "existingMatch", "hasLoaders", "routeMatch", "updatedAt", "routeSearch", "paramsError", "searchError", "loadPromise", "Promise", "resolve", "routeContext", "AbortController", "fetchedAt", "parentMatch", "searchInfo", "parentSearchInfo", "validator", "validateSearch", "SearchParamError", "contextInfo", "getContext", "parentContext", "onError", "resolvedMatches", "firstBadMatchIndex", "all", "handleError", "isRedirect", "errorHandlerErr", "setRouteMatch", "onParseParamsError", "onValidateSearchError", "beforeLoad", "onBeforeLoadError", "validResolvedMatches", "matchPromises", "then", "parentMatchPromise", "checkLatest", "latest", "latestPromise", "componentsPromise", "loaderPromise", "_", "errorHandler", "onLoadError", "caughtError", "reload", "fromCurrent", "String", "fromString", "isExternal", "URL", "baseLocation", "includeSearch", "userPreloadDelay", "nextOpts", "defaultPreload", "defaultPreloadDelay", "currentPathSplit", "nextPathSplit", "pathIsFuzzyEqual", "pathTest", "exact", "hashTest", "includeHash", "searchTest", "isCtrlEvent", "button", "console", "warn", "preloadTimeout", "setTimeout", "clearTimeout", "__do_not_use_server_ctx", "_ctx", "document", "__TSR_DEHYDRATED__", "ctx", "dehydratedData", "payload", "injectedHtml", "getData", "strKey", "escapeJSON", "routesByPath", "recurseRoutes", "routes", "existingRoute", "trimmedFullPath", "endsWith", "values", "trimmed", "parsed", "score", "child", "sort", "isIndex", "rank", "previousLocation", "parsedSearch", "parseSearch", "reverse", "dest", "fromPathname", "fromMatches", "prevParams", "nextParams", "stringifyParams", "fn", "preSearchFilters", "flat", "postSearchFilters", "preFilteredSearch", "destSearch", "postFilteredSearch", "stringifySearch", "hashStr", "nextState", "navigateTimeout", "nextAction", "isSameUrl", "previousNavigationResolve", "Store", "defaultPriority", "lastUpdated", "metaKey", "altKey", "ctrlKey", "shiftKey", "redirect", "Error", "jsonString"]
}
