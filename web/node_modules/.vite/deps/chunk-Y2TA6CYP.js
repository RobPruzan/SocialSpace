import {
  invariant,
  tiny_warning_esm_default
} from "./chunk-34INA4P6.js";
import {
  require_with_selector
} from "./chunk-JELW56M6.js";
import {
  require_react
} from "./chunk-ER55EOAS.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-NNPG3NYD.js";

// node_modules/@tanstack/router/build/esm/index.js
var React = __toESM(require_react());

// node_modules/@tanstack/react-store/build/esm/index.js
var import_with_selector = __toESM(require_with_selector());

// node_modules/@tanstack/store/build/esm/index.js
var Store = class {
  constructor(initialState, options) {
    __publicField(this, "listeners", /* @__PURE__ */ new Set());
    __publicField(this, "_batching", false);
    __publicField(this, "_flushing", 0);
    __publicField(this, "_nextPriority", null);
    __publicField(this, "subscribe", (listener) => {
      var _a, _b;
      this.listeners.add(listener);
      const unsub = (_b = (_a = this.options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
      return () => {
        this.listeners.delete(listener);
        unsub == null ? void 0 : unsub();
      };
    });
    __publicField(this, "setState", (updater, opts) => {
      var _a, _b, _c, _d, _e;
      const previous = this.state;
      this.state = ((_a = this.options) == null ? void 0 : _a.updateFn) ? this.options.updateFn(previous)(updater) : updater(previous);
      const priority = (opts == null ? void 0 : opts.priority) ?? ((_b = this.options) == null ? void 0 : _b.defaultPriority) ?? "high";
      if (this._nextPriority === null) {
        this._nextPriority = priority;
      } else if (this._nextPriority === "high") {
        this._nextPriority = priority;
      } else {
        this._nextPriority = ((_c = this.options) == null ? void 0 : _c.defaultPriority) ?? "high";
      }
      (_e = (_d = this.options) == null ? void 0 : _d.onUpdate) == null ? void 0 : _e.call(_d, {
        priority: this._nextPriority
      });
      this._flush();
    });
    __publicField(this, "_flush", () => {
      if (this._batching)
        return;
      const flushId = ++this._flushing;
      this.listeners.forEach((listener) => {
        if (this._flushing !== flushId)
          return;
        listener({
          priority: this._nextPriority ?? "high"
        });
      });
    });
    __publicField(this, "batch", (cb) => {
      if (this._batching)
        return cb();
      this._batching = true;
      cb();
      this._batching = false;
      this._flush();
    });
    this.state = initialState;
    this.options = options;
  }
};

// node_modules/@tanstack/react-store/build/esm/index.js
function useStore(store, selector = (d) => d) {
  const slice = (0, import_with_selector.useSyncExternalStoreWithSelector)(store.subscribe, () => store.state, () => store.state, selector, shallow);
  return slice;
}
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}

// node_modules/@tanstack/router/build/esm/index.js
var popStateEvent = "popstate";
var beforeUnloadEvent = "beforeunload";
var beforeUnloadListener = (event) => {
  event.preventDefault();
  return event.returnValue = "";
};
var stopBlocking = () => {
  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {
    capture: true
  });
};
function createHistory(opts) {
  let location = opts.getLocation();
  let unsub = () => {
  };
  let listeners = /* @__PURE__ */ new Set();
  let blockers = [];
  let queue = [];
  const tryFlush = () => {
    var _a, _b;
    if (blockers.length) {
      (_a = blockers[0]) == null ? void 0 : _a.call(blockers, tryFlush, () => {
        blockers = [];
        stopBlocking();
      });
      return;
    }
    while (queue.length) {
      (_b = queue.shift()) == null ? void 0 : _b();
    }
    onUpdate();
  };
  const queueTask = (task) => {
    queue.push(task);
    tryFlush();
  };
  const onUpdate = () => {
    location = opts.getLocation();
    listeners.forEach((listener) => listener());
  };
  return {
    get location() {
      return location;
    },
    listen: (cb) => {
      if (listeners.size === 0) {
        unsub = opts.listener(onUpdate);
      }
      listeners.add(cb);
      return () => {
        listeners.delete(cb);
        if (listeners.size === 0) {
          unsub();
        }
      };
    },
    push: (path, state) => {
      queueTask(() => {
        opts.pushState(path, state);
      });
    },
    replace: (path, state) => {
      queueTask(() => {
        opts.replaceState(path, state);
      });
    },
    go: (index) => {
      queueTask(() => {
        opts.go(index);
      });
    },
    back: () => {
      queueTask(() => {
        opts.back();
      });
    },
    forward: () => {
      queueTask(() => {
        opts.forward();
      });
    },
    createHref: (str) => opts.createHref(str),
    block: (cb) => {
      blockers.push(cb);
      if (blockers.length === 1) {
        addEventListener(beforeUnloadEvent, beforeUnloadListener, {
          capture: true
        });
      }
      return () => {
        blockers = blockers.filter((b) => b !== cb);
        if (!blockers.length) {
          stopBlocking();
        }
      };
    }
  };
}
function createBrowserHistory(opts) {
  const getHref = (opts == null ? void 0 : opts.getHref) ?? (() => `${window.location.pathname}${window.location.search}${window.location.hash}`);
  const createHref = (opts == null ? void 0 : opts.createHref) ?? ((path) => path);
  const getLocation = () => parseLocation(getHref(), history.state);
  return createHistory({
    getLocation,
    listener: (onUpdate) => {
      window.addEventListener(popStateEvent, onUpdate);
      return () => {
        window.removeEventListener(popStateEvent, onUpdate);
      };
    },
    pushState: (path, state) => {
      window.history.pushState({
        ...state,
        key: createRandomKey()
      }, "", createHref(path));
    },
    replaceState: (path, state) => {
      window.history.replaceState({
        ...state,
        key: createRandomKey()
      }, "", createHref(path));
    },
    back: () => window.history.back(),
    forward: () => window.history.forward(),
    go: (n) => window.history.go(n),
    createHref: (path) => createHref(path)
  });
}
function createHashHistory() {
  return createBrowserHistory({
    getHref: () => window.location.hash.substring(1),
    createHref: (path) => `#${path}`
  });
}
function createMemoryHistory(opts = {
  initialEntries: ["/"]
}) {
  const entries = opts.initialEntries;
  let index = opts.initialIndex ?? entries.length - 1;
  let currentState = {};
  const getLocation = () => parseLocation(entries[index], currentState);
  return createHistory({
    getLocation,
    listener: () => {
      return () => {
      };
    },
    pushState: (path, state) => {
      currentState = {
        ...state,
        key: createRandomKey()
      };
      entries.push(path);
      index++;
    },
    replaceState: (path, state) => {
      currentState = {
        ...state,
        key: createRandomKey()
      };
      entries[index] = path;
    },
    back: () => {
      index--;
    },
    forward: () => {
      index = Math.min(index + 1, entries.length - 1);
    },
    go: (n) => window.history.go(n),
    createHref: (path) => path
  });
}
function parseLocation(href, state) {
  let hashIndex = href.indexOf("#");
  let searchIndex = href.indexOf("?");
  return {
    href,
    pathname: href.substring(0, hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length),
    hash: hashIndex > -1 ? href.substring(hashIndex) : "",
    search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? void 0 : hashIndex) : "",
    state
  };
}
function createRandomKey() {
  return (Math.random() + 1).toString(36).substring(7);
}
function last(arr) {
  return arr[arr.length - 1];
}
function isFunction(d) {
  return typeof d === "function";
}
function functionalUpdate(updater, previous) {
  if (isFunction(updater)) {
    return updater(previous);
  }
  return updater;
}
function pick(parent, keys) {
  return keys.reduce((obj, key) => {
    obj[key] = parent[key];
    return obj;
  }, {});
}
function replaceEqualDeep(prev, _next) {
  if (prev === _next) {
    return prev;
  }
  const next = _next;
  const array = Array.isArray(prev) && Array.isArray(next);
  if (array || isPlainObject(prev) && isPlainObject(next)) {
    const prevSize = array ? prev.length : Object.keys(prev).length;
    const nextItems = array ? next : Object.keys(next);
    const nextSize = nextItems.length;
    const copy = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < nextSize; i++) {
      const key = array ? i : nextItems[i];
      copy[key] = replaceEqualDeep(prev[key], next[key]);
      if (copy[key] === prev[key]) {
        equalItems++;
      }
    }
    return prevSize === nextSize && equalItems === prevSize ? prev : copy;
  }
  return next;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function partialDeepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]));
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.length === b.length && a.every((item, index) => partialDeepEqual(item, b[index]));
  }
  return false;
}
function joinPaths(paths) {
  return cleanPath(paths.filter(Boolean).join("/"));
}
function cleanPath(path) {
  return path.replace(/\/{2,}/g, "/");
}
function trimPathLeft(path) {
  return path === "/" ? path : path.replace(/^\/{1,}/, "");
}
function trimPathRight(path) {
  return path === "/" ? path : path.replace(/\/{1,}$/, "");
}
function trimPath(path) {
  return trimPathRight(trimPathLeft(path));
}
function resolvePath(basepath, base, to) {
  base = base.replace(new RegExp(`^${basepath}`), "/");
  to = to.replace(new RegExp(`^${basepath}`), "/");
  let baseSegments = parsePathname(base);
  const toSegments = parsePathname(to);
  toSegments.forEach((toSegment, index) => {
    var _a;
    if (toSegment.value === "/") {
      if (!index) {
        baseSegments = [toSegment];
      } else if (index === toSegments.length - 1) {
        baseSegments.push(toSegment);
      } else
        ;
    } else if (toSegment.value === "..") {
      if (baseSegments.length > 1 && ((_a = last(baseSegments)) == null ? void 0 : _a.value) === "/") {
        baseSegments.pop();
      }
      baseSegments.pop();
    } else if (toSegment.value === ".") {
      return;
    } else {
      baseSegments.push(toSegment);
    }
  });
  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)]);
  return cleanPath(joined);
}
function parsePathname(pathname) {
  if (!pathname) {
    return [];
  }
  pathname = cleanPath(pathname);
  const segments = [];
  if (pathname.slice(0, 1) === "/") {
    pathname = pathname.substring(1);
    segments.push({
      type: "pathname",
      value: "/"
    });
  }
  if (!pathname) {
    return segments;
  }
  const split = pathname.split("/").filter(Boolean);
  segments.push(...split.map((part) => {
    if (part === "$" || part === "*") {
      return {
        type: "wildcard",
        value: part
      };
    }
    if (part.charAt(0) === "$") {
      return {
        type: "param",
        value: part
      };
    }
    return {
      type: "pathname",
      value: part
    };
  }));
  if (pathname.slice(-1) === "/") {
    pathname = pathname.substring(1);
    segments.push({
      type: "pathname",
      value: "/"
    });
  }
  return segments;
}
function interpolatePath(path, params, leaveWildcards = false) {
  const interpolatedPathSegments = parsePathname(path);
  return joinPaths(interpolatedPathSegments.map((segment) => {
    if (segment.type === "wildcard") {
      const value = params[segment.value];
      if (leaveWildcards)
        return `${segment.value}${value ?? ""}`;
      return value;
    }
    if (segment.type === "param") {
      return params[segment.value.substring(1)] ?? "";
    }
    return segment.value;
  }));
}
function matchPathname(basepath, currentPathname, matchLocation) {
  const pathParams = matchByPath(basepath, currentPathname, matchLocation);
  if (matchLocation.to && !pathParams) {
    return;
  }
  return pathParams ?? {};
}
function matchByPath(basepath, from, matchLocation) {
  from = basepath != "/" ? from.substring(basepath.length) : from;
  const to = `${matchLocation.to ?? "$"}`;
  const baseSegments = parsePathname(from);
  const routeSegments = parsePathname(to);
  if (!from.startsWith("/")) {
    baseSegments.unshift({
      type: "pathname",
      value: "/"
    });
  }
  if (!to.startsWith("/")) {
    routeSegments.unshift({
      type: "pathname",
      value: "/"
    });
  }
  const params = {};
  let isMatch = (() => {
    for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {
      const baseSegment = baseSegments[i];
      const routeSegment = routeSegments[i];
      const isLastBaseSegment = i >= baseSegments.length - 1;
      const isLastRouteSegment = i >= routeSegments.length - 1;
      if (routeSegment) {
        if (routeSegment.type === "wildcard") {
          if (baseSegment == null ? void 0 : baseSegment.value) {
            params["*"] = joinPaths(baseSegments.slice(i).map((d) => d.value));
            return true;
          }
          return false;
        }
        if (routeSegment.type === "pathname") {
          if (routeSegment.value === "/" && !(baseSegment == null ? void 0 : baseSegment.value)) {
            return true;
          }
          if (baseSegment) {
            if (matchLocation.caseSensitive) {
              if (routeSegment.value !== baseSegment.value) {
                return false;
              }
            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {
              return false;
            }
          }
        }
        if (!baseSegment) {
          return false;
        }
        if (routeSegment.type === "param") {
          if ((baseSegment == null ? void 0 : baseSegment.value) === "/") {
            return false;
          }
          if (baseSegment.value.charAt(0) !== "$") {
            params[routeSegment.value.substring(1)] = baseSegment.value;
          }
        }
      }
      if (!isLastBaseSegment && isLastRouteSegment) {
        return !!matchLocation.fuzzy;
      }
    }
    return true;
  })();
  return isMatch ? params : void 0;
}
function encode(obj, pfx) {
  var k, i, tmp, str = "";
  for (k in obj) {
    if ((tmp = obj[k]) !== void 0) {
      if (Array.isArray(tmp)) {
        for (i = 0; i < tmp.length; i++) {
          str && (str += "&");
          str += encodeURIComponent(k) + "=" + encodeURIComponent(tmp[i]);
        }
      } else {
        str && (str += "&");
        str += encodeURIComponent(k) + "=" + encodeURIComponent(tmp);
      }
    }
  }
  return (pfx || "") + str;
}
function toValue(mix) {
  if (!mix)
    return "";
  var str = decodeURIComponent(mix);
  if (str === "false")
    return false;
  if (str === "true")
    return true;
  if (str.charAt(0) === "0")
    return str;
  return +str * 0 === 0 ? +str : str;
}
function decode(str) {
  var tmp, k, out = {}, arr = str.split("&");
  while (tmp = arr.shift()) {
    tmp = tmp.split("=");
    k = tmp.shift();
    if (out[k] !== void 0) {
      out[k] = [].concat(out[k], toValue(tmp.shift()));
    } else {
      out[k] = toValue(tmp.shift());
    }
  }
  return out;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function lazy2(importer, exportName = "default") {
  const lazyComp = React.lazy(async () => {
    const moduleExports = await importer();
    const component = moduleExports[exportName];
    return {
      default: component
    };
  });
  const finalComp = lazyComp;
  finalComp.preload = async () => {
    {
      await importer();
    }
  };
  return finalComp;
}
function useLinkProps(options) {
  const router = useRouter();
  const {
    // custom props
    type,
    children,
    target,
    activeProps = () => ({
      className: "active"
    }),
    inactiveProps = () => ({}),
    activeOptions,
    disabled,
    // fromCurrent,
    hash,
    search,
    params,
    to = ".",
    preload,
    preloadDelay,
    replace,
    // element props
    style,
    className,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    onTouchStart,
    ...rest
  } = options;
  const linkInfo = router.buildLink(options);
  if (linkInfo.type === "external") {
    const {
      href
    } = linkInfo;
    return {
      href
    };
  }
  const {
    handleClick,
    handleFocus,
    handleEnter,
    handleLeave,
    handleTouchStart,
    isActive,
    next
  } = linkInfo;
  const handleReactClick = (e) => {
    if (options.startTransition ?? true) {
      (React.startTransition || ((d) => d))(() => {
        handleClick(e);
      });
    }
  };
  const composeHandlers = (handlers) => (e) => {
    if (e.persist)
      e.persist();
    handlers.filter(Boolean).forEach((handler) => {
      if (e.defaultPrevented)
        return;
      handler(e);
    });
  };
  const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {};
  const resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {};
  return {
    ...resolvedActiveProps,
    ...resolvedInactiveProps,
    ...rest,
    href: disabled ? void 0 : next.href,
    onClick: composeHandlers([onClick, handleReactClick]),
    onFocus: composeHandlers([onFocus, handleFocus]),
    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
    target,
    style: {
      ...style,
      ...resolvedActiveProps.style,
      ...resolvedInactiveProps.style
    },
    className: [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(" ") || void 0,
    ...disabled ? {
      role: "link",
      "aria-disabled": true
    } : void 0,
    ["data-status"]: isActive ? "active" : void 0
  };
}
var Link = React.forwardRef((props, ref) => {
  const linkProps = useLinkProps(props);
  return React.createElement("a", _extends({
    ref
  }, linkProps, {
    children: typeof props.children === "function" ? props.children({
      isActive: linkProps["data-status"] === "active"
    }) : props.children
  }));
});
function Navigate(props) {
  const router = useRouter();
  React.useLayoutEffect(() => {
    router.navigate(props);
  }, []);
  return null;
}
var matchIdsContext = React.createContext(null);
var routerContext = React.createContext(null);
function useRouterState(opts) {
  const router = useRouter();
  return useStore(router.__store, opts == null ? void 0 : opts.select);
}
function RouterProvider({
  router,
  ...rest
}) {
  router.update(rest);
  React.useEffect(router.mount, [router]);
  const Wrap = router.options.Wrap || React.Fragment;
  return React.createElement(Wrap, null, React.createElement(routerContext.Provider, {
    value: router
  }, React.createElement(Matches, null)));
}
function Matches() {
  const matchIds = useRouterState({
    select: (d) => d.matches.map((d2) => d2.id)
  });
  return React.createElement(matchIdsContext.Provider, {
    value: [void 0, ...matchIds]
  }, React.createElement(CatchBoundary, {
    errorComponent: ErrorComponent,
    onCatch: () => {
      tiny_warning_esm_default(false, `Error in router! Consider setting an 'errorComponent' in your RootRoute! 👍`);
    }
  }, React.createElement(Outlet, null)));
}
function useRouter() {
  const value = React.useContext(routerContext);
  tiny_warning_esm_default(value, "useRouter must be used inside a <Router> component!");
  return value;
}
function useMatches(opts) {
  const matchIds = React.useContext(matchIdsContext);
  return useRouterState({
    select: (state) => {
      var _a;
      const matches = state.matches.slice(state.matches.findIndex((d) => d.id === matchIds[0]));
      return ((_a = opts == null ? void 0 : opts.select) == null ? void 0 : _a.call(opts, matches)) ?? matches;
    }
  });
}
function useMatch(opts) {
  var _a;
  const router = useRouter();
  const nearestMatchId = React.useContext(matchIdsContext)[0];
  const nearestMatchRouteId = (_a = router.getRouteMatch(nearestMatchId)) == null ? void 0 : _a.routeId;
  const matchRouteId = useRouterState({
    select: (state) => {
      const matches = state.matches;
      const match2 = (opts == null ? void 0 : opts.from) ? matches.find((d) => d.routeId === (opts == null ? void 0 : opts.from)) : matches.find((d) => d.id === nearestMatchId);
      return match2.routeId;
    }
  });
  if ((opts == null ? void 0 : opts.strict) ?? true) {
    invariant(nearestMatchRouteId == matchRouteId, `useMatch("${matchRouteId}") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch("${matchRouteId}", { strict: false })' or 'useRoute("${matchRouteId}")' instead?`);
  }
  const match = useRouterState({
    select: (state) => {
      var _a2;
      const matches = state.matches;
      const match2 = (opts == null ? void 0 : opts.from) ? matches.find((d) => d.routeId === (opts == null ? void 0 : opts.from)) : matches.find((d) => d.id === nearestMatchId);
      invariant(match2, `Could not find ${(opts == null ? void 0 : opts.from) ? `an active match from "${opts.from}"` : "a nearest match!"}`);
      return ((_a2 = opts == null ? void 0 : opts.select) == null ? void 0 : _a2.call(opts, match2)) ?? match2;
    }
  });
  return match;
}
function useLoader(opts) {
  return useMatch({
    ...opts,
    select: (match) => {
      var _a;
      return ((_a = opts == null ? void 0 : opts.select) == null ? void 0 : _a.call(opts, match.loader)) ?? match.loader;
    }
  });
}
function useSearch(opts) {
  return useMatch({
    ...opts,
    select: (match) => {
      var _a;
      return ((_a = opts == null ? void 0 : opts.select) == null ? void 0 : _a.call(opts, match.search)) ?? match.search;
    }
  });
}
function useParams(opts) {
  return useRouterState({
    select: (state) => {
      var _a, _b;
      const params = (_a = last(state.matches)) == null ? void 0 : _a.params;
      return ((_b = opts == null ? void 0 : opts.select) == null ? void 0 : _b.call(opts, params)) ?? params;
    }
  });
}
function useNavigate(defaultOpts) {
  const router = useRouter();
  return React.useCallback((opts) => {
    return router.navigate({
      ...defaultOpts,
      ...opts
    });
  }, []);
}
function useMatchRoute() {
  const router = useRouter();
  return React.useCallback((opts) => {
    const {
      pending,
      caseSensitive,
      ...rest
    } = opts;
    return router.matchRoute(rest, {
      pending,
      caseSensitive
    });
  }, []);
}
function MatchRoute(props) {
  const matchRoute = useMatchRoute();
  const params = matchRoute(props);
  if (typeof props.children === "function") {
    return props.children(params);
  }
  return !!params ? props.children : null;
}
function Outlet() {
  const matchIds = React.useContext(matchIdsContext).slice(1);
  if (!matchIds[0]) {
    return null;
  }
  return React.createElement(Match, {
    matchIds
  });
}
var defaultPending = () => null;
function Match({
  matchIds
}) {
  const router = useRouter();
  const matchId = matchIds[0];
  const routeId = router.getRouteMatch(matchId).routeId;
  const route = router.getRoute(routeId);
  const PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent ?? defaultPending;
  const errorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent;
  const ResolvedSuspenseBoundary = route.options.wrapInSuspense ?? !route.isRoot ? React.Suspense : SafeFragment;
  const ResolvedCatchBoundary = errorComponent ? CatchBoundary : SafeFragment;
  return React.createElement(matchIdsContext.Provider, {
    value: matchIds
  }, React.createElement(ResolvedSuspenseBoundary, {
    fallback: React.createElement(PendingComponent, null)
  }, React.createElement(ResolvedCatchBoundary, {
    key: route.id,
    errorComponent,
    onCatch: () => {
      tiny_warning_esm_default(false, `Error in route match: ${matchId}`);
    }
  }, React.createElement(MatchInner, {
    matchId
  }))));
}
function MatchInner({
  matchId
}) {
  const router = useRouter();
  const match = useRouterState({
    select: (d) => pick(d.matches.find((d2) => d2.id === matchId), ["status", "loadPromise", "routeId", "error"])
  });
  const route = router.getRoute(match.routeId);
  if (match.status === "error") {
    throw match.error;
  }
  if (match.status === "pending") {
    invariant(false, "This should never happen");
  }
  if (match.status === "success") {
    let comp = route.options.component ?? router.options.defaultComponent;
    if (comp) {
      return React.createElement(comp, {
        useLoader: route.useLoader,
        useMatch: route.useMatch,
        useContext: route.useContext,
        useSearch: route.useSearch,
        useParams: route.useParams
      });
    }
    return React.createElement(Outlet, null);
  }
  invariant(false, "Idle routeMatch status encountered during rendering! You should never see this. File an issue!");
}
function SafeFragment(props) {
  return React.createElement(React.Fragment, null, props.children);
}
function useInjectHtml() {
  const router = useRouter();
  return React.useCallback((html) => {
    router.injectHtml(html);
  }, []);
}
function useDehydrate() {
  const router = useRouter();
  return React.useCallback(function dehydrate(key, data) {
    return router.dehydrateData(key, data);
  }, []);
}
function useHydrate() {
  const router = useRouter();
  return function hydrate(key) {
    return router.hydrateData(key);
  };
}
var CatchBoundary = class extends React.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      error: false,
      info: void 0
    });
  }
  componentDidCatch(error, info) {
    this.props.onCatch(error, info);
    this.setState({
      error,
      info
    });
  }
  render() {
    return React.createElement(CatchBoundaryInner, _extends({}, this.props, {
      errorState: this.state,
      reset: () => this.setState({})
    }));
  }
};
function CatchBoundaryInner(props) {
  const locationKey = useRouterState({
    select: (d) => d.resolvedLocation.key
  });
  const [activeErrorState, setActiveErrorState] = React.useState(props.errorState);
  const errorComponent = props.errorComponent ?? ErrorComponent;
  const prevKeyRef = React.useRef("");
  React.useEffect(() => {
    if (activeErrorState) {
      if (locationKey !== prevKeyRef.current) {
        setActiveErrorState({});
      }
    }
    prevKeyRef.current = locationKey;
  }, [activeErrorState, locationKey]);
  React.useEffect(() => {
    if (props.errorState.error) {
      setActiveErrorState(props.errorState);
    }
  }, [props.errorState.error]);
  if (props.errorState.error && activeErrorState.error) {
    return React.createElement(errorComponent, activeErrorState);
  }
  return props.children;
}
function ErrorComponent({
  error
}) {
  return React.createElement("div", {
    style: {
      padding: ".5rem",
      maxWidth: "100%"
    }
  }, React.createElement("strong", {
    style: {
      fontSize: "1.2rem"
    }
  }, "Something went wrong!"), React.createElement("div", {
    style: {
      height: ".5rem"
    }
  }), React.createElement("div", null, React.createElement("pre", {
    style: {
      fontSize: ".7em",
      border: "1px solid red",
      borderRadius: ".25rem",
      padding: ".5rem",
      color: "red",
      overflow: "auto"
    }
  }, error.message ? React.createElement("code", null, error.message) : null)));
}
function useBlocker(message, condition = true) {
  const router = useRouter();
  React.useEffect(() => {
    if (!condition)
      return;
    let unblock = router.history.block((retry, cancel) => {
      if (window.confirm(message)) {
        unblock();
        retry();
      }
    });
    return unblock;
  });
}
function Block({
  message,
  condition,
  children
}) {
  useBlocker(message, condition);
  return children ?? null;
}
function shallow2(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
var rootRouteId = "__root__";
var Route = class {
  // Set up in this.init()
  // customId!: TCustomId
  // Optional
  constructor(options) {
    __publicField(this, "init", (opts) => {
      var _a, _b;
      this.originalIndex = opts.originalIndex;
      this.router = opts.router;
      const allOptions = this.options;
      const isRoot = !(allOptions == null ? void 0 : allOptions.path) && !(allOptions == null ? void 0 : allOptions.id);
      this.parentRoute = (_b = (_a = this.options) == null ? void 0 : _a.getParentRoute) == null ? void 0 : _b.call(_a);
      if (isRoot) {
        this.path = rootRouteId;
      } else {
        invariant(this.parentRoute, `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`);
      }
      let path = isRoot ? rootRouteId : allOptions.path;
      if (path && path !== "/") {
        path = trimPath(path);
      }
      const customId = (allOptions == null ? void 0 : allOptions.id) || path;
      let id = isRoot ? rootRouteId : joinPaths([this.parentRoute.id === rootRouteId ? "" : this.parentRoute.id, customId]);
      if (path === rootRouteId) {
        path = "/";
      }
      if (id !== rootRouteId) {
        id = joinPaths(["/", id]);
      }
      const fullPath = id === rootRouteId ? "/" : joinPaths([this.parentRoute.fullPath, path]);
      this.path = path;
      this.id = id;
      this.fullPath = fullPath;
      this.to = fullPath;
    });
    __publicField(this, "addChildren", (children) => {
      this.children = children;
      return this;
    });
    __publicField(this, "useMatch", (opts) => {
      return useMatch({
        ...opts,
        from: this.id
      });
    });
    __publicField(this, "useLoader", (opts) => {
      return useLoader({
        ...opts,
        from: this.id
      });
    });
    __publicField(this, "useContext", (opts) => {
      return useMatch({
        ...opts,
        from: this.id,
        select: (d) => {
          var _a;
          return ((_a = opts == null ? void 0 : opts.select) == null ? void 0 : _a.call(opts, d.context)) ?? d.context;
        }
      });
    });
    __publicField(this, "useSearch", (opts) => {
      return useSearch({
        ...opts,
        from: this.id
      });
    });
    __publicField(this, "useParams", (opts) => {
      return useParams({
        ...opts,
        from: this.id
      });
    });
    this.options = options || {};
    this.isRoot = !(options == null ? void 0 : options.getParentRoute);
  }
};
var RouterContext = class {
  constructor() {
    __publicField(this, "createRootRoute", (options) => {
      return new RootRoute(options);
    });
  }
  //   return <
  //     TLoader = unknown,
  //     TSearchSchema extends AnySearchSchema = {},
  //     TContext extends {} = {},
  //   >(
  //     options?: Omit<
  //       RouteOptions<
  //         AnyRoute,
  //         RootRouteId,
  //         '',
  //         TLoader,
  //         {},
  //         TSearchSchema,
  //         NoInfer<TSearchSchema>,
  //         {},
  //         TRouterContext,
  //         TRouterContext,
  //         TContext,
  //         TRouterContext & TContext
  //       >,
  //       'path' | 'id' | 'getParentRoute' | 'caseSensitive'
  //     >,
  //   ) =>
  //     new RootRoute<TLoader, TSearchSchema, TContext, TRouterContext>(
  //       options as any,
  //     )
  // }
};
var RootRoute = class extends Route {
  constructor(options) {
    super(options);
  }
};
var defaultParseSearch = parseSearchWith(JSON.parse);
var defaultStringifySearch = stringifySearchWith(JSON.stringify);
function parseSearchWith(parser) {
  return (searchStr) => {
    if (searchStr.substring(0, 1) === "?") {
      searchStr = searchStr.substring(1);
    }
    let query = decode(searchStr);
    for (let key in query) {
      const value = query[key];
      if (typeof value === "string") {
        try {
          query[key] = parser(value);
        } catch (err) {
        }
      }
    }
    return query;
  };
}
function stringifySearchWith(stringify) {
  return (search) => {
    search = {
      ...search
    };
    if (search) {
      Object.keys(search).forEach((key) => {
        const val = search[key];
        if (typeof val === "undefined" || val === void 0) {
          delete search[key];
        } else if (val && typeof val === "object" && val !== null) {
          try {
            search[key] = stringify(val);
          } catch (err) {
          }
        }
      });
    }
    const searchStr = encode(search).toString();
    return searchStr ? `?${searchStr}` : "";
  };
}
var componentTypes = ["component", "errorComponent", "pendingComponent"];
var _unsubHistory, _buildRouteTree, _parseLocation, _buildLocation, _commitLocation, _createNavigationPromise, _setResolvedRouteMatch, _setPendingRouteMatch, _setPreloadRouteMatch;
var Router = class {
  constructor(options) {
    __privateAdd(this, _unsubHistory, void 0);
    __publicField(this, "startedLoadingAt", Date.now());
    __publicField(this, "resolveNavigation", () => {
    });
    __publicField(this, "reset", () => {
      this.__store.setState((s) => Object.assign(s, getInitialRouterState()));
    });
    __publicField(this, "mount", () => {
      if (!this.state.matches.length) {
        this.safeLoad();
      }
    });
    __publicField(this, "update", (opts) => {
      this.options = {
        ...this.options,
        ...opts,
        context: {
          ...this.options.context,
          ...opts == null ? void 0 : opts.context
        }
      };
      if (!this.history || this.options.history && this.options.history !== this.history) {
        if (__privateGet(this, _unsubHistory)) {
          __privateGet(this, _unsubHistory).call(this);
        }
        this.history = this.options.history ?? (isServer ? createMemoryHistory() : createBrowserHistory());
        const parsedLocation = __privateGet(this, _parseLocation).call(this);
        this.__store.setState((s) => ({
          ...s,
          resolvedLocation: parsedLocation,
          location: parsedLocation
        }));
        __privateSet(this, _unsubHistory, this.history.listen(() => {
          this.safeLoad({
            next: __privateGet(this, _parseLocation).call(this, this.state.location)
          });
        }));
      }
      const {
        basepath,
        routeTree
      } = this.options;
      this.basepath = `/${trimPath(basepath ?? "") ?? ""}`;
      if (routeTree && routeTree !== this.routeTree) {
        __privateGet(this, _buildRouteTree).call(this, routeTree);
      }
      return this;
    });
    __publicField(this, "buildNext", (opts) => {
      const next = __privateGet(this, _buildLocation).call(this, opts);
      const __matches = this.matchRoutes(next.pathname, next.search);
      return __privateGet(this, _buildLocation).call(this, {
        ...opts,
        __matches
      });
    });
    __publicField(this, "cancelMatches", () => {
      this.state.matches.forEach((match) => {
        this.cancelMatch(match.id);
      });
    });
    __publicField(this, "cancelMatch", (id) => {
      var _a, _b;
      (_b = (_a = this.getRouteMatch(id)) == null ? void 0 : _a.abortController) == null ? void 0 : _b.abort();
    });
    __publicField(this, "safeLoad", (opts) => {
      this.load(opts).catch((err) => {
      });
    });
    __publicField(this, "load", async (opts) => {
      var _a, _b;
      __privateGet(this, _createNavigationPromise).call(this);
      let now = Date.now();
      const startedAt = now;
      this.startedLoadingAt = startedAt;
      this.cancelMatches();
      let pendingMatches;
      this.__store.batch(() => {
        if (opts == null ? void 0 : opts.next) {
          this.__store.setState((s) => ({
            ...s,
            location: opts.next
          }));
        }
        pendingMatches = this.matchRoutes(this.state.location.pathname, this.state.location.search, {
          // throwOnError: true,
        });
        this.__store.setState((s) => ({
          ...s,
          status: "pending",
          pendingMatches
        }));
      });
      await this.loadMatches(pendingMatches);
      if (this.startedLoadingAt !== startedAt) {
        return this.navigationPromise;
      }
      const prevLocation = this.state.resolvedLocation;
      this.__store.setState((s) => ({
        ...s,
        status: "idle",
        resolvedLocation: s.location,
        matches: s.pendingMatches,
        pendingMatches: []
      }));
      if (prevLocation.href !== this.state.location.href) {
        (_b = (_a = this.options).onRouteChange) == null ? void 0 : _b.call(_a);
      }
      this.resolveNavigation();
    });
    __publicField(this, "getRoute", (id) => {
      const route = this.routesById[id];
      invariant(route, `Route with id "${id}" not found`);
      return route;
    });
    __publicField(this, "preloadRoute", async (navigateOpts = this.state.location) => {
      const next = this.buildNext(navigateOpts);
      const matches = this.matchRoutes(next.pathname, next.search, {
        throwOnError: true
      });
      const matchesById = {};
      matches.forEach((m) => {
        if (!this.state.matches.find((d) => d.id === m.id)) {
          matchesById[m.id] = m;
        }
      });
      this.__store.setState((s) => {
        return {
          ...s,
          preloadMatches: {
            ...s.preloadMatches,
            ...matchesById
          }
        };
      });
      await this.loadMatches(matches, {
        preload: true
      });
      return matches;
    });
    __publicField(this, "matchRoutes", (pathname, locationSearch, opts) => {
      let routeParams = {};
      let foundRoute = this.flatRoutes.find((route) => {
        const matchedParams = matchPathname(this.basepath, pathname, {
          to: route.fullPath,
          caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive
        });
        if (matchedParams) {
          routeParams = matchedParams;
          return true;
        }
        return false;
      });
      let routeCursor = foundRoute || this.routesById["__root__"];
      let matchedRoutes = [routeCursor];
      while (routeCursor == null ? void 0 : routeCursor.parentRoute) {
        routeCursor = routeCursor.parentRoute;
        if (routeCursor)
          matchedRoutes.unshift(routeCursor);
      }
      let allParams = {};
      const matches = matchedRoutes.map((route) => {
        var _a, _b, _c, _d;
        let parsedParams;
        let parsedParamsError;
        try {
          parsedParams = ((_b = (_a = route.options).parseParams) == null ? void 0 : _b.call(_a, routeParams)) ?? routeParams;
        } catch (err) {
          parsedParamsError = new PathParamError(err.message, {
            cause: err
          });
          if (opts == null ? void 0 : opts.throwOnError) {
            throw parsedParamsError;
          }
        }
        Object.assign(allParams, parsedParams);
        const interpolatedPath = interpolatePath(route.path, allParams);
        const matchId = interpolatePath(route.id, allParams, true) + (((_d = (_c = route.options).getKey) == null ? void 0 : _d.call(_c, {
          params: allParams,
          search: locationSearch
        })) ?? "");
        const existingMatch = this.getRouteMatch(matchId);
        if (existingMatch) {
          return {
            ...existingMatch
          };
        }
        const hasLoaders = !!(route.options.loader || componentTypes.some((d) => {
          var _a2;
          return (_a2 = route.options[d]) == null ? void 0 : _a2.preload;
        }));
        const routeMatch = {
          id: matchId,
          routeId: route.id,
          params: allParams,
          pathname: joinPaths([this.basepath, interpolatedPath]),
          updatedAt: 0,
          routeSearch: {},
          search: {},
          status: hasLoaders ? "pending" : "success",
          error: void 0,
          paramsError: parsedParamsError,
          searchError: void 0,
          loader: void 0,
          loadPromise: Promise.resolve(),
          routeContext: void 0,
          context: void 0,
          abortController: new AbortController(),
          fetchedAt: 0
        };
        return routeMatch;
      });
      matches.forEach((match, i) => {
        const parentMatch = matches[i - 1];
        const route = this.getRoute(match.routeId);
        const searchInfo = (() => {
          const parentSearchInfo = {
            search: (parentMatch == null ? void 0 : parentMatch.search) ?? locationSearch,
            routeSearch: (parentMatch == null ? void 0 : parentMatch.routeSearch) ?? locationSearch
          };
          try {
            const validator = typeof route.options.validateSearch === "object" ? route.options.validateSearch.parse : route.options.validateSearch;
            const routeSearch = (validator == null ? void 0 : validator(parentSearchInfo.search)) ?? {};
            const search = {
              ...parentSearchInfo.search,
              ...routeSearch
            };
            return {
              routeSearch: replaceEqualDeep(match.routeSearch, routeSearch),
              search: replaceEqualDeep(match.search, search)
            };
          } catch (err) {
            match.searchError = new SearchParamError(err.message, {
              cause: err
            });
            if (opts == null ? void 0 : opts.throwOnError) {
              throw match.searchError;
            }
            return parentSearchInfo;
          }
        })();
        const contextInfo = (() => {
          var _a, _b, _c, _d;
          try {
            const routeContext = ((_b = (_a = route.options).getContext) == null ? void 0 : _b.call(_a, {
              parentContext: (parentMatch == null ? void 0 : parentMatch.routeContext) ?? {},
              context: (parentMatch == null ? void 0 : parentMatch.context) ?? (this == null ? void 0 : this.options.context) ?? {},
              params: match.params,
              search: match.search
            })) || {};
            const context = {
              ...(parentMatch == null ? void 0 : parentMatch.context) ?? (this == null ? void 0 : this.options.context),
              ...routeContext
            };
            return {
              context,
              routeContext
            };
          } catch (err) {
            (_d = (_c = route.options).onError) == null ? void 0 : _d.call(_c, err);
            throw err;
          }
        })();
        Object.assign(match, {
          ...searchInfo,
          ...contextInfo
        });
      });
      return matches;
    });
    __publicField(this, "loadMatches", async (resolvedMatches, opts) => {
      let firstBadMatchIndex;
      try {
        await Promise.all(resolvedMatches.map(async (match, index) => {
          var _a, _b;
          const route = this.getRoute(match.routeId);
          const handleError = (err, handler) => {
            firstBadMatchIndex = firstBadMatchIndex ?? index;
            handler = handler || route.options.onError;
            if (isRedirect(err)) {
              throw err;
            }
            try {
              handler == null ? void 0 : handler(err);
            } catch (errorHandlerErr) {
              err = errorHandlerErr;
              if (isRedirect(errorHandlerErr)) {
                throw errorHandlerErr;
              }
            }
            this.setRouteMatch(match.id, (s) => ({
              ...s,
              error: err,
              status: "error",
              updatedAt: Date.now()
            }));
          };
          if (match.paramsError) {
            handleError(match.paramsError, route.options.onParseParamsError);
          }
          if (match.searchError) {
            handleError(match.searchError, route.options.onValidateSearchError);
          }
          try {
            await ((_b = (_a = route.options).beforeLoad) == null ? void 0 : _b.call(_a, {
              router: this,
              match
            }));
          } catch (err) {
            handleError(err, route.options.onBeforeLoadError);
          }
        }));
      } catch (err) {
        if (isRedirect(err)) {
          if (!(opts == null ? void 0 : opts.preload)) {
            this.navigate(err);
          }
          return;
        }
        throw err;
      }
      const validResolvedMatches = resolvedMatches.slice(0, firstBadMatchIndex);
      const matchPromises = [];
      validResolvedMatches.forEach((match, index) => {
        matchPromises.push(Promise.resolve().then(async () => {
          const parentMatchPromise = matchPromises[index - 1];
          const route = this.getRoute(match.routeId);
          const fetchedAt = Date.now();
          const loadPromise = Promise.resolve().then(async () => {
            const checkLatest = () => {
              const latest = this.getRouteMatch(match.id);
              return latest && latest.fetchedAt !== fetchedAt ? latest.loadPromise : void 0;
            };
            let latestPromise;
            const componentsPromise = (async () => {
              await Promise.all(componentTypes.map(async (type) => {
                const component = route.options[type];
                if (component == null ? void 0 : component.preload) {
                  await component.preload();
                }
              }));
            })();
            const loaderPromise = Promise.resolve().then(() => {
              if (route.options.loader) {
                return route.options.loader({
                  ...match,
                  preload: !!(opts == null ? void 0 : opts.preload),
                  parentMatchPromise
                });
              }
              return;
            });
            try {
              const [_, loader] = await Promise.all([componentsPromise, loaderPromise]);
              if (latestPromise = checkLatest())
                return await latestPromise;
              if (!(opts == null ? void 0 : opts.preload) || !this.state.matches.find((d) => d.id === match.id)) {
                this.setRouteMatch(match.id, (s) => ({
                  ...s,
                  error: void 0,
                  status: "success",
                  updatedAt: Date.now(),
                  loader
                }));
              }
            } catch (err) {
              if (latestPromise = checkLatest())
                return await latestPromise;
              if (isRedirect(err)) {
                if (!(opts == null ? void 0 : opts.preload)) {
                  this.navigate(err);
                }
                return;
              }
              const errorHandler = route.options.onLoadError ?? route.options.onError;
              let caughtError = err;
              try {
                errorHandler == null ? void 0 : errorHandler(err);
              } catch (errorHandlerErr) {
                caughtError = errorHandlerErr;
                if (isRedirect(errorHandlerErr)) {
                  if (!(opts == null ? void 0 : opts.preload)) {
                    this.navigate(errorHandlerErr);
                  }
                  return;
                }
              }
              this.setRouteMatch(match.id, (s) => ({
                ...s,
                error: caughtError,
                status: "error",
                updatedAt: Date.now()
              }));
            } finally {
              if (latestPromise = checkLatest())
                return await latestPromise;
              if (opts == null ? void 0 : opts.preload) {
                this.__store.setState((s) => {
                  const preloadMatches = {
                    ...s.preloadMatches
                  };
                  delete preloadMatches[match.id];
                  return {
                    ...s,
                    preloadMatches
                  };
                });
              }
            }
          });
          this.setRouteMatch(match.id, (s) => ({
            ...s,
            loadPromise,
            fetchedAt
          }));
          await loadPromise;
        }));
      });
      await Promise.all(matchPromises);
    });
    __publicField(this, "reload", () => {
      this.navigate({
        fromCurrent: true,
        replace: true,
        search: true
      });
    });
    __publicField(this, "resolvePath", (from, path) => {
      return resolvePath(this.basepath, from, cleanPath(path));
    });
    __publicField(this, "navigate", async ({
      from,
      to = "",
      search,
      hash,
      replace,
      params
    }) => {
      const toString = String(to);
      const fromString = typeof from === "undefined" ? from : String(from);
      let isExternal;
      try {
        new URL(`${toString}`);
        isExternal = true;
      } catch (e) {
      }
      invariant(!isExternal, "Attempting to navigate to external url with this.navigate!");
      return __privateGet(this, _commitLocation).call(this, {
        from: fromString,
        to: toString,
        search,
        hash,
        replace,
        params
      });
    });
    __publicField(this, "matchRoute", (location, opts) => {
      location = {
        ...location,
        to: location.to ? this.resolvePath(location.from ?? "", location.to) : void 0
      };
      const next = this.buildNext(location);
      if ((opts == null ? void 0 : opts.pending) && this.state.status !== "pending") {
        return false;
      }
      const baseLocation = (opts == null ? void 0 : opts.pending) ? this.state.location : this.state.resolvedLocation;
      if (!baseLocation) {
        return false;
      }
      const match = matchPathname(this.basepath, baseLocation.pathname, {
        ...opts,
        to: next.pathname
      });
      if (!match) {
        return false;
      }
      if ((opts == null ? void 0 : opts.includeSearch) ?? true) {
        return partialDeepEqual(baseLocation.search, next.search) ? match : false;
      }
      return match;
    });
    __publicField(this, "buildLink", ({
      from,
      to = ".",
      search,
      params,
      hash,
      target,
      replace,
      activeOptions,
      preload,
      preloadDelay: userPreloadDelay,
      disabled
    }) => {
      try {
        new URL(`${to}`);
        return {
          type: "external",
          href: to
        };
      } catch (e) {
      }
      const nextOpts = {
        from,
        to,
        search,
        params,
        hash,
        replace
      };
      const next = this.buildNext(nextOpts);
      preload = preload ?? this.options.defaultPreload;
      const preloadDelay = userPreloadDelay ?? this.options.defaultPreloadDelay ?? 0;
      const currentPathSplit = this.state.location.pathname.split("/");
      const nextPathSplit = next.pathname.split("/");
      const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);
      const pathTest = (activeOptions == null ? void 0 : activeOptions.exact) ? this.state.location.pathname === next.pathname : pathIsFuzzyEqual;
      const hashTest = (activeOptions == null ? void 0 : activeOptions.includeHash) ? this.state.location.hash === next.hash : true;
      const searchTest = (activeOptions == null ? void 0 : activeOptions.includeSearch) ?? true ? partialDeepEqual(this.state.location.search, next.search) : true;
      const isActive = pathTest && hashTest && searchTest;
      const handleClick = (e) => {
        if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === "_self") && e.button === 0) {
          e.preventDefault();
          __privateGet(this, _commitLocation).call(this, nextOpts);
        }
      };
      const handleFocus = (e) => {
        if (preload) {
          this.preloadRoute(nextOpts).catch((err) => {
            console.warn(err);
            console.warn("Error preloading route! ☝️");
          });
        }
      };
      const handleTouchStart = (e) => {
        this.preloadRoute(nextOpts).catch((err) => {
          console.warn(err);
          console.warn("Error preloading route! ☝️");
        });
      };
      const handleEnter = (e) => {
        const target2 = e.target || {};
        if (preload) {
          if (target2.preloadTimeout) {
            return;
          }
          target2.preloadTimeout = setTimeout(() => {
            target2.preloadTimeout = null;
            this.preloadRoute(nextOpts).catch((err) => {
              console.warn(err);
              console.warn("Error preloading route! ☝️");
            });
          }, preloadDelay);
        }
      };
      const handleLeave = (e) => {
        const target2 = e.target || {};
        if (target2.preloadTimeout) {
          clearTimeout(target2.preloadTimeout);
          target2.preloadTimeout = null;
        }
      };
      return {
        type: "internal",
        next,
        handleFocus,
        handleClick,
        handleEnter,
        handleLeave,
        handleTouchStart,
        isActive,
        disabled
      };
    });
    __publicField(this, "dehydrate", () => {
      return {
        state: pick(this.state, ["location", "status", "lastUpdated"])
      };
    });
    __publicField(this, "hydrate", async (__do_not_use_server_ctx) => {
      var _a, _b;
      let _ctx = __do_not_use_server_ctx;
      if (typeof document !== "undefined") {
        _ctx = window.__TSR_DEHYDRATED__;
      }
      invariant(_ctx, "Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?");
      const ctx = _ctx;
      this.dehydratedData = ctx.payload;
      (_b = (_a = this.options).hydrate) == null ? void 0 : _b.call(_a, ctx.payload);
      this.__store.setState((s) => {
        return {
          ...s,
          ...ctx.router.state,
          matches: s.matches,
          resolvedLocation: ctx.router.state.location
        };
      });
      await this.load();
      return;
    });
    __publicField(this, "injectedHtml", []);
    __publicField(this, "injectHtml", async (html) => {
      this.injectedHtml.push(html);
    });
    __publicField(this, "dehydrateData", (key, getData) => {
      if (typeof document === "undefined") {
        const strKey = typeof key === "string" ? key : JSON.stringify(key);
        this.injectHtml(async () => {
          const id = `__TSR_DEHYDRATED__${strKey}`;
          const data = typeof getData === "function" ? await getData() : getData;
          return `<script id='${id}' suppressHydrationWarning>window["__TSR_DEHYDRATED__${escapeJSON(strKey)}"] = ${JSON.stringify(data)}
        ;(() => {
          var el = document.getElementById('${id}')
          el.parentElement.removeChild(el)
        })()
        <\/script>`;
        });
        return () => this.hydrateData(key);
      }
      return () => void 0;
    });
    __publicField(this, "hydrateData", (key) => {
      if (typeof document !== "undefined") {
        const strKey = typeof key === "string" ? key : JSON.stringify(key);
        return window[`__TSR_DEHYDRATED__${strKey}`];
      }
      return void 0;
    });
    // resolveMatchPromise = (matchId: string, key: string, value: any) => {
    //   this.state.matches
    //     .find((d) => d.id === matchId)
    //     ?.__promisesByKey[key]?.resolve(value)
    // }
    __privateAdd(this, _buildRouteTree, (routeTree) => {
      this.routeTree = routeTree;
      this.routesById = {};
      this.routesByPath = {};
      this.flatRoutes = [];
      const recurseRoutes = (routes) => {
        routes.forEach((route, i) => {
          route.init({
            originalIndex: i,
            router: this
          });
          const existingRoute = this.routesById[route.id];
          invariant(!existingRoute, `Duplicate routes found with id: ${String(route.id)}`);
          this.routesById[route.id] = route;
          if (!route.isRoot && route.path) {
            const trimmedFullPath = trimPathRight(route.fullPath);
            if (!this.routesByPath[trimmedFullPath] || route.fullPath.endsWith("/")) {
              this.routesByPath[trimmedFullPath] = route;
            }
          }
          const children = route.children;
          if (children == null ? void 0 : children.length) {
            recurseRoutes(children);
          }
        });
      };
      recurseRoutes([routeTree]);
      this.flatRoutes = Object.values(this.routesByPath).map((d, i) => {
        var _a;
        const trimmed = trimPath(d.fullPath);
        const parsed = parsePathname(trimmed);
        while (parsed.length > 1 && ((_a = parsed[0]) == null ? void 0 : _a.value) === "/") {
          parsed.shift();
        }
        const score = parsed.map((d2) => {
          if (d2.type === "param") {
            return 0.5;
          }
          if (d2.type === "wildcard") {
            return 0.25;
          }
          return 1;
        });
        return {
          child: d,
          trimmed,
          parsed,
          index: i,
          score
        };
      }).sort((a, b) => {
        let isIndex = a.trimmed === "/" ? 1 : b.trimmed === "/" ? -1 : 0;
        if (isIndex !== 0)
          return isIndex;
        const length = Math.min(a.score.length, b.score.length);
        if (a.score.length !== b.score.length) {
          return b.score.length - a.score.length;
        }
        for (let i = 0; i < length; i++) {
          if (a.score[i] !== b.score[i]) {
            return b.score[i] - a.score[i];
          }
        }
        for (let i = 0; i < length; i++) {
          if (a.parsed[i].value !== b.parsed[i].value) {
            return a.parsed[i].value > b.parsed[i].value ? 1 : -1;
          }
        }
        if (a.trimmed !== b.trimmed) {
          return a.trimmed > b.trimmed ? 1 : -1;
        }
        return a.index - b.index;
      }).map((d, i) => {
        d.child.rank = i;
        return d.child;
      });
    });
    __privateAdd(this, _parseLocation, (previousLocation) => {
      let {
        pathname,
        search,
        hash,
        state
      } = this.history.location;
      const parsedSearch = this.options.parseSearch(search);
      return {
        pathname,
        searchStr: search,
        search: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),
        hash: hash.split("#").reverse()[0] ?? "",
        href: `${pathname}${search}${hash}`,
        state,
        key: (state == null ? void 0 : state.key) || "__init__"
      };
    });
    __privateAdd(this, _buildLocation, (dest = {}) => {
      var _a, _b, _c, _d;
      dest.fromCurrent = dest.fromCurrent ?? dest.to === "";
      const fromPathname = dest.fromCurrent ? this.state.location.pathname : dest.from ?? this.state.location.pathname;
      let pathname = resolvePath(this.basepath ?? "/", fromPathname, `${dest.to ?? ""}`);
      const fromMatches = this.matchRoutes(this.state.location.pathname, this.state.location.search);
      const prevParams = {
        ...(_a = last(fromMatches)) == null ? void 0 : _a.params
      };
      let nextParams = (dest.params ?? true) === true ? prevParams : functionalUpdate(dest.params, prevParams);
      if (nextParams) {
        (_b = dest.__matches) == null ? void 0 : _b.map((d) => this.getRoute(d.routeId).options.stringifyParams).filter(Boolean).forEach((fn) => {
          nextParams = {
            ...nextParams,
            ...fn(nextParams)
          };
        });
      }
      pathname = interpolatePath(pathname, nextParams ?? {});
      const preSearchFilters = ((_c = dest.__matches) == null ? void 0 : _c.map((match) => this.getRoute(match.routeId).options.preSearchFilters ?? []).flat().filter(Boolean)) ?? [];
      const postSearchFilters = ((_d = dest.__matches) == null ? void 0 : _d.map((match) => this.getRoute(match.routeId).options.postSearchFilters ?? []).flat().filter(Boolean)) ?? [];
      const preFilteredSearch = (preSearchFilters == null ? void 0 : preSearchFilters.length) ? preSearchFilters == null ? void 0 : preSearchFilters.reduce((prev, next) => next(prev), this.state.location.search) : this.state.location.search;
      const destSearch = dest.search === true ? preFilteredSearch : dest.search ? functionalUpdate(dest.search, preFilteredSearch) ?? {} : (preSearchFilters == null ? void 0 : preSearchFilters.length) ? preFilteredSearch : {};
      const postFilteredSearch = (postSearchFilters == null ? void 0 : postSearchFilters.length) ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;
      const search = replaceEqualDeep(this.state.location.search, postFilteredSearch);
      const searchStr = this.options.stringifySearch(search);
      const hash = dest.hash === true ? this.state.location.hash : functionalUpdate(dest.hash, this.state.location.hash);
      const hashStr = hash ? `#${hash}` : "";
      const nextState = dest.state === true ? this.state.location.state : functionalUpdate(dest.state, this.state.location.state);
      return {
        pathname,
        search,
        searchStr,
        state: nextState,
        hash,
        href: this.history.createHref(`${pathname}${searchStr}${hashStr}`),
        key: dest.key
      };
    });
    __privateAdd(this, _commitLocation, async (location) => {
      const next = this.buildNext(location);
      const id = "" + Date.now() + Math.random();
      if (this.navigateTimeout)
        clearTimeout(this.navigateTimeout);
      let nextAction = "replace";
      if (!location.replace) {
        nextAction = "push";
      }
      const isSameUrl = this.state.location.href === next.href;
      if (isSameUrl && !next.key) {
        nextAction = "replace";
      }
      const href = `${next.pathname}${next.searchStr}${next.hash ? `#${next.hash}` : ""}`;
      this.history[nextAction === "push" ? "push" : "replace"](href, {
        id,
        ...next.state
      });
      return __privateGet(this, _createNavigationPromise).call(this);
    });
    __privateAdd(this, _createNavigationPromise, () => {
      const previousNavigationResolve = this.resolveNavigation;
      this.navigationPromise = new Promise((resolve) => {
        this.resolveNavigation = () => {
          resolve();
          previousNavigationResolve();
        };
      });
      return this.navigationPromise;
    });
    __publicField(this, "getRouteMatch", (id) => {
      return this.state.matches.find((d) => d.id === id) || this.state.preloadMatches[id];
    });
    __privateAdd(this, _setResolvedRouteMatch, (id, updater) => {
      this.__store.setState((prev) => ({
        ...prev,
        matches: prev.matches.map((d) => {
          if (d.id === id) {
            return updater(d);
          }
          return d;
        })
      }));
    });
    __privateAdd(this, _setPendingRouteMatch, (id, updater) => {
      this.__store.setState((prev) => ({
        ...prev,
        pendingMatches: prev.pendingMatches.map((d) => {
          if (d.id === id) {
            return updater(d);
          }
          return d;
        })
      }));
    });
    __privateAdd(this, _setPreloadRouteMatch, (id, updater) => {
      invariant(this.state.preloadMatches[id], "Match not found");
      this.__store.setState((prev) => ({
        ...prev,
        preloadMatches: {
          ...prev.preloadMatches,
          [id]: updater(prev.preloadMatches[id])
        }
      }));
    });
    __publicField(this, "setRouteMatch", (id, updater) => {
      if (this.state.matches.find((d) => d.id === id)) {
        return __privateGet(this, _setResolvedRouteMatch).call(this, id, updater);
      }
      if (this.state.pendingMatches.find((d) => d.id === id)) {
        return __privateGet(this, _setPendingRouteMatch).call(this, id, updater);
      }
      if (this.state.preloadMatches[id]) {
        return __privateGet(this, _setPreloadRouteMatch).call(this, id, updater);
      }
    });
    this.options = {
      defaultPreloadDelay: 50,
      context: void 0,
      ...options,
      stringifySearch: (options == null ? void 0 : options.stringifySearch) ?? defaultStringifySearch,
      parseSearch: (options == null ? void 0 : options.parseSearch) ?? defaultParseSearch
      // fetchServerDataFn: options?.fetchServerDataFn ?? defaultFetchServerDataFn,
    };
    this.__store = new Store(getInitialRouterState(), {
      onUpdate: () => {
        this.state = this.__store.state;
      },
      defaultPriority: "low"
    });
    this.state = this.__store.state;
    this.update(options);
    const next = this.buildNext({
      hash: true,
      fromCurrent: true,
      search: true,
      state: true
    });
    if (this.state.location.href !== next.href) {
      __privateGet(this, _commitLocation).call(this, {
        ...next,
        replace: true
      });
    }
  }
};
_unsubHistory = new WeakMap();
_buildRouteTree = new WeakMap();
_parseLocation = new WeakMap();
_buildLocation = new WeakMap();
_commitLocation = new WeakMap();
_createNavigationPromise = new WeakMap();
_setResolvedRouteMatch = new WeakMap();
_setPendingRouteMatch = new WeakMap();
_setPreloadRouteMatch = new WeakMap();
var isServer = typeof window === "undefined" || !window.document.createElement;
function getInitialRouterState() {
  return {
    status: "idle",
    resolvedLocation: null,
    location: null,
    matches: [],
    pendingMatches: [],
    preloadMatches: {},
    lastUpdated: Date.now()
  };
}
function isCtrlEvent(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function redirect(opts) {
  opts.isRedirect = true;
  return opts;
}
function isRedirect(obj) {
  return !!(obj == null ? void 0 : obj.isRedirect);
}
var SearchParamError = class extends Error {
};
var PathParamError = class extends Error {
};
function escapeJSON(jsonString) {
  return jsonString.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/"/g, '\\"');
}

export {
  useStore,
  createBrowserHistory,
  createHashHistory,
  createMemoryHistory,
  last,
  functionalUpdate,
  pick,
  replaceEqualDeep,
  isPlainObject,
  partialDeepEqual,
  joinPaths,
  cleanPath,
  trimPathLeft,
  trimPathRight,
  trimPath,
  resolvePath,
  parsePathname,
  interpolatePath,
  matchPathname,
  matchByPath,
  encode,
  decode,
  lazy2 as lazy,
  useLinkProps,
  Link,
  Navigate,
  matchIdsContext,
  routerContext,
  useRouterState,
  RouterProvider,
  useRouter,
  useMatches,
  useMatch,
  useLoader,
  useSearch,
  useParams,
  useNavigate,
  useMatchRoute,
  MatchRoute,
  Outlet,
  useInjectHtml,
  useDehydrate,
  useHydrate,
  ErrorComponent,
  useBlocker,
  Block,
  shallow2 as shallow,
  rootRouteId,
  Route,
  RouterContext,
  RootRoute,
  defaultParseSearch,
  defaultStringifySearch,
  parseSearchWith,
  stringifySearchWith,
  componentTypes,
  Router,
  redirect,
  isRedirect,
  SearchParamError,
  PathParamError
};
/*! Bundled license information:

@tanstack/store/build/esm/index.js:
  (**
   * @tanstack/store/src/index.ts
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/react-store/build/esm/index.js:
  (**
   * @tanstack/react-store/src/index.tsx
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/router/build/esm/index.js:
  (**
   * @tanstack/router/src/index.ts
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-Y2TA6CYP.js.map
