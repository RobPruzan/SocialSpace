/// <reference types="react" />
import { Store } from '@tanstack/react-store';
import { LinkInfo, LinkOptions, NavigateOptions, ToOptions, ResolveRelativePath } from './link';
import { Route, AnySearchSchema, AnyRoute, RootRoute, AnyContext } from './route';
import { RoutesInfo, AnyRoutesInfo, RoutesById, RoutesByPath, DefaultRoutesInfo } from './routeInfo';
import { NoInfer, PickAsRequired, Timeout, Updater } from './utils';
import { RouterHistory } from './history';
import { RouteComponent } from './react';
declare global {
    interface Window {
        __TSR_DEHYDRATED__?: HydrationCtx;
    }
    interface Error {
        cause: unknown;
    }
    interface ErrorConstructor {
        new (reason: string, options?: {
            cause?: unknown;
        }): Error;
    }
}
export interface Register {
}
export type AnyRouter = Router<any, any, any>;
export type RegisteredRouterPair = Register extends {
    router: infer TRouter extends AnyRouter;
} ? [TRouter, TRouter['types']['RoutesInfo']] : [Router, AnyRoutesInfo];
export type RegisteredRouter = RegisteredRouterPair[0];
export type RegisteredRoutesInfo = RegisteredRouterPair[1];
export interface LocationState {
}
export interface ParsedLocation<TSearchObj extends AnySearchSchema = {}, TState extends LocationState = LocationState> {
    href: string;
    pathname: string;
    search: TSearchObj;
    searchStr: string;
    state: TState;
    hash: string;
    key?: string;
}
export interface FromLocation {
    pathname: string;
    search?: unknown;
    key?: string;
    hash?: string;
}
export type SearchSerializer = (searchObj: Record<string, any>) => string;
export type SearchParser = (searchStr: string) => Record<string, any>;
export type HydrationCtx = {
    router: DehydratedRouter;
    payload: Record<string, any>;
};
export interface RouteMatch<TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo, TRoute extends AnyRoute = Route> {
    id: string;
    routeId: string;
    pathname: string;
    params: TRoute['__types']['allParams'];
    status: 'pending' | 'success' | 'error';
    error: unknown;
    paramsError: unknown;
    searchError: unknown;
    updatedAt: number;
    loader: TRoute['__types']['loader'];
    loadPromise?: Promise<void>;
    __resolveLoadPromise?: () => void;
    routeContext: TRoute['__types']['routeContext'];
    context: TRoute['__types']['context'];
    routeSearch: TRoute['__types']['searchSchema'];
    search: TRoutesInfo['fullSearchSchema'] & TRoute['__types']['fullSearchSchema'];
    fetchedAt: number;
    abortController: AbortController;
}
export type AnyRouteMatch = RouteMatch<AnyRoutesInfo, AnyRoute>;
export type RouterContextOptions<TRouteTree extends AnyRoute> = AnyContext extends TRouteTree['__types']['routerContext'] ? {
    context?: TRouteTree['__types']['routerContext'];
} : {
    context: TRouteTree['__types']['routerContext'];
};
export interface RouterOptions<TRouteTree extends AnyRoute, TDehydrated extends Record<string, any>> {
    history?: RouterHistory;
    stringifySearch?: SearchSerializer;
    parseSearch?: SearchParser;
    defaultPreload?: false | 'intent';
    defaultPreloadDelay?: number;
    defaultComponent?: RouteComponent;
    defaultErrorComponent?: RouteComponent<{
        error: Error;
        info: {
            componentStack: string;
        };
    }>;
    defaultPendingComponent?: RouteComponent;
    defaultLoaderMaxAge?: number;
    defaultLoaderGcMaxAge?: number;
    caseSensitive?: boolean;
    routeTree?: TRouteTree;
    basepath?: string;
    createRoute?: (opts: {
        route: AnyRoute;
        router: AnyRouter;
    }) => void;
    onRouteChange?: () => void;
    context?: TRouteTree['__types']['routerContext'];
    Wrap?: React.ComponentType<{
        children: React.ReactNode;
        dehydratedState?: TDehydrated;
    }>;
    dehydrate?: () => TDehydrated;
    hydrate?: (dehydrated: TDehydrated) => void;
}
export interface RouterState<TRoutesInfo extends AnyRoutesInfo = AnyRoutesInfo, TState extends LocationState = LocationState> {
    status: 'idle' | 'pending';
    matches: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[];
    pendingMatches: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[];
    preloadMatches: Record<string, RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>>;
    location: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>;
    resolvedLocation: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>;
    lastUpdated: number;
}
export type ListenerFn = () => void;
export interface BuildNextOptions {
    to?: string | number | null;
    params?: true | Updater<unknown>;
    search?: true | Updater<unknown>;
    hash?: true | Updater<string>;
    state?: LocationState;
    key?: string;
    from?: string;
    fromCurrent?: boolean;
    __matches?: AnyRouteMatch[];
}
export interface MatchLocation {
    to?: string | number | null;
    fuzzy?: boolean;
    caseSensitive?: boolean;
    from?: string;
    fromCurrent?: boolean;
}
export interface MatchRouteOptions {
    pending?: boolean;
    caseSensitive?: boolean;
    includeSearch?: boolean;
    fuzzy?: boolean;
}
export interface DehydratedRouterState extends Pick<RouterState, 'status' | 'location' | 'lastUpdated'> {
}
export interface DehydratedRouter {
    state: DehydratedRouterState;
}
export type RouterConstructorOptions<TRouteTree extends AnyRoute, TDehydrated extends Record<string, any>> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & RouterContextOptions<TRouteTree>;
export declare const componentTypes: readonly ["component", "errorComponent", "pendingComponent"];
export declare class Router<TRouteTree extends AnyRoute = AnyRoute, TRoutesInfo extends AnyRoutesInfo = RoutesInfo<TRouteTree>, TDehydrated extends Record<string, any> = Record<string, any>> {
    #private;
    types: {
        RootRoute: TRouteTree;
        RoutesInfo: TRoutesInfo;
    };
    options: PickAsRequired<RouterOptions<TRouteTree, TDehydrated>, 'stringifySearch' | 'parseSearch' | 'context'>;
    history: RouterHistory;
    basepath: string;
    routeTree: RootRoute;
    routesById: RoutesById<TRoutesInfo>;
    routesByPath: RoutesByPath<TRoutesInfo>;
    flatRoutes: TRoutesInfo['routesByFullPath'][keyof TRoutesInfo['routesByFullPath']][];
    navigateTimeout: undefined | Timeout;
    nextAction: undefined | 'push' | 'replace';
    navigationPromise: undefined | Promise<void>;
    __store: Store<RouterState<TRoutesInfo>>;
    state: RouterState<TRoutesInfo>;
    startedLoadingAt: number;
    resolveNavigation: () => void;
    dehydratedData?: TDehydrated;
    constructor(options: RouterConstructorOptions<TRouteTree, TDehydrated>);
    reset: () => void;
    mount: () => void;
    update: (opts?: RouterOptions<any, any>) => this;
    buildNext: (opts: BuildNextOptions) => ParsedLocation;
    cancelMatches: () => void;
    cancelMatch: (id: string) => void;
    safeLoad: (opts?: {
        next?: ParsedLocation;
    }) => void;
    load: (opts?: {
        next?: ParsedLocation;
    }) => Promise<void>;
    getRoute: <TId extends keyof TRoutesInfo["routesById"]>(id: TId) => TRoutesInfo["routesById"][TId];
    preloadRoute: (navigateOpts?: BuildNextOptions) => Promise<RouteMatch<TRoutesInfo, TRoutesInfo["routeIntersection"]>[]>;
    matchRoutes: (pathname: string, locationSearch: AnySearchSchema, opts?: {
        throwOnError?: boolean;
    }) => RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[];
    loadMatches: (resolvedMatches: AnyRouteMatch[], opts?: {
        preload?: boolean;
    }) => Promise<void>;
    reload: () => void;
    resolvePath: (from: string, path: string) => string;
    navigate: <TFrom extends string = "/", TTo extends string = "">({ from, to, search, hash, replace, params, }: NavigateOptions<TRoutesInfo, TFrom, TTo>) => Promise<void>;
    matchRoute: <TFrom extends string = "/", TTo extends string = "", TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>>(location: ToOptions<TRoutesInfo, TFrom, TTo, ResolveRelativePath<TFrom, NoInfer<TTo>>>, opts?: MatchRouteOptions) => false | TRoutesInfo["routesById"][TResolved]["__types"]["allParams"];
    buildLink: <TFrom extends string = "/", TTo extends string = "">({ from, to, search, params, hash, target, replace, activeOptions, preload, preloadDelay: userPreloadDelay, disabled, }: LinkOptions<TRoutesInfo, TFrom, TTo>) => LinkInfo;
    dehydrate: () => DehydratedRouter;
    hydrate: (__do_not_use_server_ctx?: HydrationCtx) => Promise<void>;
    injectedHtml: (string | (() => Promise<string> | string))[];
    injectHtml: (html: string | (() => Promise<string> | string)) => Promise<void>;
    dehydrateData: <T>(key: any, getData: T | (() => T | Promise<T>)) => () => T | undefined;
    hydrateData: <T = unknown>(key: any) => T | undefined;
    getRouteMatch: (id: string) => undefined | RouteMatch<TRoutesInfo, AnyRoute>;
    setRouteMatch: (id: string, updater: (prev: RouteMatch<TRoutesInfo, AnyRoute>) => RouteMatch<TRoutesInfo, AnyRoute>) => void;
}
export type AnyRedirect = Redirect<any, any, any>;
export type Redirect<TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo, TFrom extends TRoutesInfo['routePaths'] = '/', TTo extends string = ''> = NavigateOptions<TRoutesInfo, TFrom, TTo> & {
    code?: number;
};
export declare function redirect<TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo, TFrom extends TRoutesInfo['routePaths'] = '/', TTo extends string = ''>(opts: Redirect<TRoutesInfo, TFrom, TTo>): Redirect<TRoutesInfo, TFrom, TTo>;
export declare function isRedirect(obj: any): obj is AnyRedirect;
export declare class SearchParamError extends Error {
}
export declare class PathParamError extends Error {
}
