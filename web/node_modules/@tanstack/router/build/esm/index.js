/**
 * @tanstack/router/src/index.ts
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import invariant from 'tiny-invariant';
export { default as invariant } from 'tiny-invariant';
import warning from 'tiny-warning';
export { default as warning } from 'tiny-warning';
import * as React from 'react';
import { useStore, Store } from '@tanstack/react-store';
export { useStore } from '@tanstack/react-store';

// While the public API was clearly inspired by the "history" npm package,
// This implementation attempts to be more lightweight by
// making assumptions about the way TanStack Router works

const popStateEvent = 'popstate';
const beforeUnloadEvent = 'beforeunload';
const beforeUnloadListener = event => {
  event.preventDefault();
  // @ts-ignore
  return event.returnValue = '';
};
const stopBlocking = () => {
  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {
    capture: true
  });
};
function createHistory(opts) {
  let location = opts.getLocation();
  let unsub = () => {};
  let listeners = new Set();
  let blockers = [];
  let queue = [];
  const tryFlush = () => {
    if (blockers.length) {
      blockers[0]?.(tryFlush, () => {
        blockers = [];
        stopBlocking();
      });
      return;
    }
    while (queue.length) {
      queue.shift()?.();
    }
    onUpdate();
  };
  const queueTask = task => {
    queue.push(task);
    tryFlush();
  };
  const onUpdate = () => {
    location = opts.getLocation();
    listeners.forEach(listener => listener());
  };
  return {
    get location() {
      return location;
    },
    listen: cb => {
      if (listeners.size === 0) {
        unsub = opts.listener(onUpdate);
      }
      listeners.add(cb);
      return () => {
        listeners.delete(cb);
        if (listeners.size === 0) {
          unsub();
        }
      };
    },
    push: (path, state) => {
      queueTask(() => {
        opts.pushState(path, state);
      });
    },
    replace: (path, state) => {
      queueTask(() => {
        opts.replaceState(path, state);
      });
    },
    go: index => {
      queueTask(() => {
        opts.go(index);
      });
    },
    back: () => {
      queueTask(() => {
        opts.back();
      });
    },
    forward: () => {
      queueTask(() => {
        opts.forward();
      });
    },
    createHref: str => opts.createHref(str),
    block: cb => {
      blockers.push(cb);
      if (blockers.length === 1) {
        addEventListener(beforeUnloadEvent, beforeUnloadListener, {
          capture: true
        });
      }
      return () => {
        blockers = blockers.filter(b => b !== cb);
        if (!blockers.length) {
          stopBlocking();
        }
      };
    }
  };
}
function createBrowserHistory(opts) {
  const getHref = opts?.getHref ?? (() => `${window.location.pathname}${window.location.search}${window.location.hash}`);
  const createHref = opts?.createHref ?? (path => path);
  const getLocation = () => parseLocation(getHref(), history.state);
  return createHistory({
    getLocation,
    listener: onUpdate => {
      window.addEventListener(popStateEvent, onUpdate);
      return () => {
        window.removeEventListener(popStateEvent, onUpdate);
      };
    },
    pushState: (path, state) => {
      window.history.pushState({
        ...state,
        key: createRandomKey()
      }, '', createHref(path));
    },
    replaceState: (path, state) => {
      window.history.replaceState({
        ...state,
        key: createRandomKey()
      }, '', createHref(path));
    },
    back: () => window.history.back(),
    forward: () => window.history.forward(),
    go: n => window.history.go(n),
    createHref: path => createHref(path)
  });
}
function createHashHistory() {
  return createBrowserHistory({
    getHref: () => window.location.hash.substring(1),
    createHref: path => `#${path}`
  });
}
function createMemoryHistory(opts = {
  initialEntries: ['/']
}) {
  const entries = opts.initialEntries;
  let index = opts.initialIndex ?? entries.length - 1;
  let currentState = {};
  const getLocation = () => parseLocation(entries[index], currentState);
  return createHistory({
    getLocation,
    listener: () => {
      return () => {};
    },
    pushState: (path, state) => {
      currentState = {
        ...state,
        key: createRandomKey()
      };
      entries.push(path);
      index++;
    },
    replaceState: (path, state) => {
      currentState = {
        ...state,
        key: createRandomKey()
      };
      entries[index] = path;
    },
    back: () => {
      index--;
    },
    forward: () => {
      index = Math.min(index + 1, entries.length - 1);
    },
    go: n => window.history.go(n),
    createHref: path => path
  });
}
function parseLocation(href, state) {
  let hashIndex = href.indexOf('#');
  let searchIndex = href.indexOf('?');
  return {
    href,
    pathname: href.substring(0, hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length),
    hash: hashIndex > -1 ? href.substring(hashIndex) : '',
    search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex) : '',
    state
  };
}

// Thanks co-pilot!
function createRandomKey() {
  return (Math.random() + 1).toString(36).substring(7);
}

function last(arr) {
  return arr[arr.length - 1];
}
function isFunction(d) {
  return typeof d === 'function';
}
function functionalUpdate(updater, previous) {
  if (isFunction(updater)) {
    return updater(previous);
  }
  return updater;
}
function pick(parent, keys) {
  return keys.reduce((obj, key) => {
    obj[key] = parent[key];
    return obj;
  }, {});
}

/**
 * This function returns `a` if `b` is deeply equal.
 * If not, it will replace any deeply equal children of `b` with those of `a`.
 * This can be used for structural sharing between immutable JSON values for example.
 * Do not use this with signals
 */
function replaceEqualDeep(prev, _next) {
  if (prev === _next) {
    return prev;
  }
  const next = _next;
  const array = Array.isArray(prev) && Array.isArray(next);
  if (array || isPlainObject(prev) && isPlainObject(next)) {
    const prevSize = array ? prev.length : Object.keys(prev).length;
    const nextItems = array ? next : Object.keys(next);
    const nextSize = nextItems.length;
    const copy = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < nextSize; i++) {
      const key = array ? i : nextItems[i];
      copy[key] = replaceEqualDeep(prev[key], next[key]);
      if (copy[key] === prev[key]) {
        equalItems++;
      }
    }
    return prevSize === nextSize && equalItems === prevSize ? prev : copy;
  }
  return next;
}

// Copied from: https://github.com/jonschlinkert/is-plain-object
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }

  // If has modified constructor
  const ctor = o.constructor;
  if (typeof ctor === 'undefined') {
    return true;
  }

  // If has modified prototype
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }

  // If constructor does not have an Object-specific method
  if (!prot.hasOwnProperty('isPrototypeOf')) {
    return false;
  }

  // Most likely a plain Object
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}
function partialDeepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.length === b.length && a.every((item, index) => partialDeepEqual(item, b[index]));
  }
  return false;
}

function joinPaths(paths) {
  return cleanPath(paths.filter(Boolean).join('/'));
}
function cleanPath(path) {
  // remove double slashes
  return path.replace(/\/{2,}/g, '/');
}
function trimPathLeft(path) {
  return path === '/' ? path : path.replace(/^\/{1,}/, '');
}
function trimPathRight(path) {
  return path === '/' ? path : path.replace(/\/{1,}$/, '');
}
function trimPath(path) {
  return trimPathRight(trimPathLeft(path));
}
function resolvePath(basepath, base, to) {
  base = base.replace(new RegExp(`^${basepath}`), '/');
  to = to.replace(new RegExp(`^${basepath}`), '/');
  let baseSegments = parsePathname(base);
  const toSegments = parsePathname(to);
  toSegments.forEach((toSegment, index) => {
    if (toSegment.value === '/') {
      if (!index) {
        // Leading slash
        baseSegments = [toSegment];
      } else if (index === toSegments.length - 1) {
        // Trailing Slash
        baseSegments.push(toSegment);
      } else ;
    } else if (toSegment.value === '..') {
      // Extra trailing slash? pop it off
      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {
        baseSegments.pop();
      }
      baseSegments.pop();
    } else if (toSegment.value === '.') {
      return;
    } else {
      baseSegments.push(toSegment);
    }
  });
  const joined = joinPaths([basepath, ...baseSegments.map(d => d.value)]);
  return cleanPath(joined);
}
function parsePathname(pathname) {
  if (!pathname) {
    return [];
  }
  pathname = cleanPath(pathname);
  const segments = [];
  if (pathname.slice(0, 1) === '/') {
    pathname = pathname.substring(1);
    segments.push({
      type: 'pathname',
      value: '/'
    });
  }
  if (!pathname) {
    return segments;
  }

  // Remove empty segments and '.' segments
  const split = pathname.split('/').filter(Boolean);
  segments.push(...split.map(part => {
    if (part === '$' || part === '*') {
      return {
        type: 'wildcard',
        value: part
      };
    }
    if (part.charAt(0) === '$') {
      return {
        type: 'param',
        value: part
      };
    }
    return {
      type: 'pathname',
      value: part
    };
  }));
  if (pathname.slice(-1) === '/') {
    pathname = pathname.substring(1);
    segments.push({
      type: 'pathname',
      value: '/'
    });
  }
  return segments;
}
function interpolatePath(path, params, leaveWildcards = false) {
  const interpolatedPathSegments = parsePathname(path);
  return joinPaths(interpolatedPathSegments.map(segment => {
    if (segment.type === 'wildcard') {
      const value = params[segment.value];
      if (leaveWildcards) return `${segment.value}${value ?? ''}`;
      return value;
    }
    if (segment.type === 'param') {
      return params[segment.value.substring(1)] ?? '';
    }
    return segment.value;
  }));
}
function matchPathname(basepath, currentPathname, matchLocation) {
  const pathParams = matchByPath(basepath, currentPathname, matchLocation);
  // const searchMatched = matchBySearch(location.search, matchLocation)

  if (matchLocation.to && !pathParams) {
    return;
  }
  return pathParams ?? {};
}
function matchByPath(basepath, from, matchLocation) {
  // Remove the base path from the pathname
  from = basepath != '/' ? from.substring(basepath.length) : from;
  // Default to to $ (wildcard)
  const to = `${matchLocation.to ?? '$'}`;
  // Parse the from and to
  const baseSegments = parsePathname(from);
  const routeSegments = parsePathname(to);
  if (!from.startsWith('/')) {
    baseSegments.unshift({
      type: 'pathname',
      value: '/'
    });
  }
  if (!to.startsWith('/')) {
    routeSegments.unshift({
      type: 'pathname',
      value: '/'
    });
  }
  const params = {};
  let isMatch = (() => {
    for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {
      const baseSegment = baseSegments[i];
      const routeSegment = routeSegments[i];
      const isLastBaseSegment = i >= baseSegments.length - 1;
      const isLastRouteSegment = i >= routeSegments.length - 1;
      if (routeSegment) {
        if (routeSegment.type === 'wildcard') {
          if (baseSegment?.value) {
            params['*'] = joinPaths(baseSegments.slice(i).map(d => d.value));
            return true;
          }
          return false;
        }
        if (routeSegment.type === 'pathname') {
          if (routeSegment.value === '/' && !baseSegment?.value) {
            return true;
          }
          if (baseSegment) {
            if (matchLocation.caseSensitive) {
              if (routeSegment.value !== baseSegment.value) {
                return false;
              }
            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {
              return false;
            }
          }
        }
        if (!baseSegment) {
          return false;
        }
        if (routeSegment.type === 'param') {
          if (baseSegment?.value === '/') {
            return false;
          }
          if (baseSegment.value.charAt(0) !== '$') {
            params[routeSegment.value.substring(1)] = baseSegment.value;
          }
        }
      }
      if (!isLastBaseSegment && isLastRouteSegment) {
        return !!matchLocation.fuzzy;
      }
    }
    return true;
  })();
  return isMatch ? params : undefined;
}

// @ts-nocheck

// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.

function encode(obj, pfx) {
  var k,
    i,
    tmp,
    str = '';
  for (k in obj) {
    if ((tmp = obj[k]) !== void 0) {
      if (Array.isArray(tmp)) {
        for (i = 0; i < tmp.length; i++) {
          str && (str += '&');
          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i]);
        }
      } else {
        str && (str += '&');
        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp);
      }
    }
  }
  return (pfx || '') + str;
}
function toValue(mix) {
  if (!mix) return '';
  var str = decodeURIComponent(mix);
  if (str === 'false') return false;
  if (str === 'true') return true;
  if (str.charAt(0) === '0') return str;
  return +str * 0 === 0 ? +str : str;
}
function decode(str) {
  var tmp,
    k,
    out = {},
    arr = str.split('&');
  while (tmp = arr.shift()) {
    tmp = tmp.split('=');
    k = tmp.shift();
    if (out[k] !== void 0) {
      out[k] = [].concat(out[k], toValue(tmp.shift()));
    } else {
      out[k] = toValue(tmp.shift());
    }
  }
  return out;
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

//

function lazy(importer, exportName = 'default') {
  const lazyComp = /*#__PURE__*/React.lazy(async () => {
    const moduleExports = await importer();
    const component = moduleExports[exportName];
    return {
      default: component
    };
  });
  const finalComp = lazyComp;
  finalComp.preload = async () => {
    {
      await importer();
    }
  };
  return finalComp;
}
//

function useLinkProps(options) {
  const router = useRouter();
  const {
    // custom props
    type,
    children,
    target,
    activeProps = () => ({
      className: 'active'
    }),
    inactiveProps = () => ({}),
    activeOptions,
    disabled,
    // fromCurrent,
    hash,
    search,
    params,
    to = '.',
    preload,
    preloadDelay,
    replace,
    // element props
    style,
    className,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    onTouchStart,
    ...rest
  } = options;
  const linkInfo = router.buildLink(options);
  if (linkInfo.type === 'external') {
    const {
      href
    } = linkInfo;
    return {
      href
    };
  }
  const {
    handleClick,
    handleFocus,
    handleEnter,
    handleLeave,
    handleTouchStart,
    isActive,
    next
  } = linkInfo;
  const handleReactClick = e => {
    if (options.startTransition ?? true) {
      (React.startTransition || (d => d))(() => {
        handleClick(e);
      });
    }
  };
  const composeHandlers = handlers => e => {
    if (e.persist) e.persist();
    handlers.filter(Boolean).forEach(handler => {
      if (e.defaultPrevented) return;
      handler(e);
    });
  };

  // Get the active props
  const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {};

  // Get the inactive props
  const resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {};
  return {
    ...resolvedActiveProps,
    ...resolvedInactiveProps,
    ...rest,
    href: disabled ? undefined : next.href,
    onClick: composeHandlers([onClick, handleReactClick]),
    onFocus: composeHandlers([onFocus, handleFocus]),
    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
    target,
    style: {
      ...style,
      ...resolvedActiveProps.style,
      ...resolvedInactiveProps.style
    },
    className: [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(' ') || undefined,
    ...(disabled ? {
      role: 'link',
      'aria-disabled': true
    } : undefined),
    ['data-status']: isActive ? 'active' : undefined
  };
}
const Link = /*#__PURE__*/React.forwardRef((props, ref) => {
  const linkProps = useLinkProps(props);
  return /*#__PURE__*/React.createElement("a", _extends({
    ref: ref
  }, linkProps, {
    children: typeof props.children === 'function' ? props.children({
      isActive: linkProps['data-status'] === 'active'
    }) : props.children
  }));
});
function Navigate(props) {
  const router = useRouter();
  React.useLayoutEffect(() => {
    router.navigate(props);
  }, []);
  return null;
}
const matchIdsContext = /*#__PURE__*/React.createContext(null);
const routerContext = /*#__PURE__*/React.createContext(null);
function useRouterState(opts) {
  const router = useRouter();
  return useStore(router.__store, opts?.select);
}
function RouterProvider({
  router,
  ...rest
}) {
  router.update(rest);
  React.useEffect(router.mount, [router]);
  const Wrap = router.options.Wrap || React.Fragment;
  return /*#__PURE__*/React.createElement(Wrap, null, /*#__PURE__*/React.createElement(routerContext.Provider, {
    value: router
  }, /*#__PURE__*/React.createElement(Matches, null)));
}
function Matches() {
  const matchIds = useRouterState({
    select: d => d.matches.map(d => d.id)
  });
  return /*#__PURE__*/React.createElement(matchIdsContext.Provider, {
    value: [undefined, ...matchIds]
  }, /*#__PURE__*/React.createElement(CatchBoundary, {
    errorComponent: ErrorComponent,
    onCatch: () => {
      warning(false, `Error in router! Consider setting an 'errorComponent' in your RootRoute! 👍`);
    }
  }, /*#__PURE__*/React.createElement(Outlet, null)));
}
function useRouter() {
  const value = React.useContext(routerContext);
  warning(value, 'useRouter must be used inside a <Router> component!');
  return value;
}
function useMatches(opts) {
  const matchIds = React.useContext(matchIdsContext);
  return useRouterState({
    select: state => {
      const matches = state.matches.slice(state.matches.findIndex(d => d.id === matchIds[0]));
      return opts?.select?.(matches) ?? matches;
    }
  });
}
function useMatch(opts) {
  const router = useRouter();
  const nearestMatchId = React.useContext(matchIdsContext)[0];
  const nearestMatchRouteId = router.getRouteMatch(nearestMatchId)?.routeId;
  const matchRouteId = useRouterState({
    select: state => {
      const matches = state.matches;
      const match = opts?.from ? matches.find(d => d.routeId === opts?.from) : matches.find(d => d.id === nearestMatchId);
      return match.routeId;
    }
  });
  if (opts?.strict ?? true) {
    invariant(nearestMatchRouteId == matchRouteId, `useMatch("${matchRouteId}") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch("${matchRouteId}", { strict: false })' or 'useRoute("${matchRouteId}")' instead?`);
  }
  const match = useRouterState({
    select: state => {
      const matches = state.matches;
      const match = opts?.from ? matches.find(d => d.routeId === opts?.from) : matches.find(d => d.id === nearestMatchId);
      invariant(match, `Could not find ${opts?.from ? `an active match from "${opts.from}"` : 'a nearest match!'}`);
      return opts?.select?.(match) ?? match;
    }
  });
  return match;
}
function useLoader(opts) {
  return useMatch({
    ...opts,
    select: match => opts?.select?.(match.loader) ?? match.loader
  });
}
function useSearch(opts) {
  return useMatch({
    ...opts,
    select: match => {
      return opts?.select?.(match.search) ?? match.search;
    }
  });
}
function useParams(opts) {
  return useRouterState({
    select: state => {
      const params = last(state.matches)?.params;
      return opts?.select?.(params) ?? params;
    }
  });
}
function useNavigate(defaultOpts) {
  const router = useRouter();
  return React.useCallback(opts => {
    return router.navigate({
      ...defaultOpts,
      ...opts
    });
  }, []);
}
function useMatchRoute() {
  const router = useRouter();
  return React.useCallback(opts => {
    const {
      pending,
      caseSensitive,
      ...rest
    } = opts;
    return router.matchRoute(rest, {
      pending,
      caseSensitive
    });
  }, []);
}
function MatchRoute(props) {
  const matchRoute = useMatchRoute();
  const params = matchRoute(props);
  if (typeof props.children === 'function') {
    return props.children(params);
  }
  return !!params ? props.children : null;
}
function Outlet() {
  const matchIds = React.useContext(matchIdsContext).slice(1);
  if (!matchIds[0]) {
    return null;
  }
  return /*#__PURE__*/React.createElement(Match, {
    matchIds: matchIds
  });
}
const defaultPending = () => null;
function Match({
  matchIds
}) {
  const router = useRouter();
  const matchId = matchIds[0];
  const routeId = router.getRouteMatch(matchId).routeId;
  const route = router.getRoute(routeId);
  const PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent ?? defaultPending;
  const errorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent;
  const ResolvedSuspenseBoundary = route.options.wrapInSuspense ?? !route.isRoot ? React.Suspense : SafeFragment;
  const ResolvedCatchBoundary = errorComponent ? CatchBoundary : SafeFragment;
  return /*#__PURE__*/React.createElement(matchIdsContext.Provider, {
    value: matchIds
  }, /*#__PURE__*/React.createElement(ResolvedSuspenseBoundary, {
    fallback: /*#__PURE__*/React.createElement(PendingComponent, null)
  }, /*#__PURE__*/React.createElement(ResolvedCatchBoundary, {
    key: route.id,
    errorComponent: errorComponent,
    onCatch: () => {
      warning(false, `Error in route match: ${matchId}`);
    }
  }, /*#__PURE__*/React.createElement(MatchInner, {
    matchId: matchId
  }))));
}
function MatchInner({
  matchId
}) {
  const router = useRouter();
  const match = useRouterState({
    select: d => pick(d.matches.find(d => d.id === matchId), ['status', 'loadPromise', 'routeId', 'error'])
  });
  const route = router.getRoute(match.routeId);
  if (match.status === 'error') {
    throw match.error;
  }
  if (match.status === 'pending') {
    invariant(false, 'This should never happen');
  }
  if (match.status === 'success') {
    let comp = route.options.component ?? router.options.defaultComponent;
    if (comp) {
      return /*#__PURE__*/React.createElement(comp, {
        useLoader: route.useLoader,
        useMatch: route.useMatch,
        useContext: route.useContext,
        useSearch: route.useSearch,
        useParams: route.useParams
      });
    }
    return /*#__PURE__*/React.createElement(Outlet, null);
  }
  invariant(false, 'Idle routeMatch status encountered during rendering! You should never see this. File an issue!');
}
function SafeFragment(props) {
  return /*#__PURE__*/React.createElement(React.Fragment, null, props.children);
}
function useInjectHtml() {
  const router = useRouter();
  return React.useCallback(html => {
    router.injectHtml(html);
  }, []);
}
function useDehydrate() {
  const router = useRouter();
  return React.useCallback(function dehydrate(key, data) {
    return router.dehydrateData(key, data);
  }, []);
}
function useHydrate() {
  const router = useRouter();
  return function hydrate(key) {
    return router.hydrateData(key);
  };
}

// This is the messiest thing ever... I'm either seriously tired (likely) or
// there has to be a better way to reset error boundaries when the
// router's location key changes.

class CatchBoundary extends React.Component {
  state = {
    error: false,
    info: undefined
  };
  componentDidCatch(error, info) {
    this.props.onCatch(error, info);
    this.setState({
      error,
      info
    });
  }
  render() {
    return /*#__PURE__*/React.createElement(CatchBoundaryInner, _extends({}, this.props, {
      errorState: this.state,
      reset: () => this.setState({})
    }));
  }
}
function CatchBoundaryInner(props) {
  const locationKey = useRouterState({
    select: d => d.resolvedLocation.key
  });
  const [activeErrorState, setActiveErrorState] = React.useState(props.errorState);
  const errorComponent = props.errorComponent ?? ErrorComponent;
  const prevKeyRef = React.useRef('');
  React.useEffect(() => {
    if (activeErrorState) {
      if (locationKey !== prevKeyRef.current) {
        setActiveErrorState({});
      }
    }
    prevKeyRef.current = locationKey;
  }, [activeErrorState, locationKey]);
  React.useEffect(() => {
    if (props.errorState.error) {
      setActiveErrorState(props.errorState);
    }
    // props.reset()
  }, [props.errorState.error]);
  if (props.errorState.error && activeErrorState.error) {
    return /*#__PURE__*/React.createElement(errorComponent, activeErrorState);
  }
  return props.children;
}
function ErrorComponent({
  error
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      padding: '.5rem',
      maxWidth: '100%'
    }
  }, /*#__PURE__*/React.createElement("strong", {
    style: {
      fontSize: '1.2rem'
    }
  }, "Something went wrong!"), /*#__PURE__*/React.createElement("div", {
    style: {
      height: '.5rem'
    }
  }), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("pre", {
    style: {
      fontSize: '.7em',
      border: '1px solid red',
      borderRadius: '.25rem',
      padding: '.5rem',
      color: 'red',
      overflow: 'auto'
    }
  }, error.message ? /*#__PURE__*/React.createElement("code", null, error.message) : null)));
}
function useBlocker(message, condition = true) {
  const router = useRouter();
  React.useEffect(() => {
    if (!condition) return;
    let unblock = router.history.block((retry, cancel) => {
      if (window.confirm(message)) {
        unblock();
        retry();
      }
    });
    return unblock;
  });
}
function Block({
  message,
  condition,
  children
}) {
  useBlocker(message, condition);
  return children ?? null;
}
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}

const rootRouteId = '__root__';
class Route {
  // Set up in this.init()

  // customId!: TCustomId

  // Optional

  constructor(options) {
    this.options = options || {};
    this.isRoot = !options?.getParentRoute;
  }
  init = opts => {
    this.originalIndex = opts.originalIndex;
    this.router = opts.router;
    const allOptions = this.options;
    const isRoot = !allOptions?.path && !allOptions?.id;
    this.parentRoute = this.options?.getParentRoute?.();
    if (isRoot) {
      this.path = rootRouteId;
    } else {
      invariant(this.parentRoute, `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`);
    }
    let path = isRoot ? rootRouteId : allOptions.path;

    // If the path is anything other than an index path, trim it up
    if (path && path !== '/') {
      path = trimPath(path);
    }
    const customId = allOptions?.id || path;

    // Strip the parentId prefix from the first level of children
    let id = isRoot ? rootRouteId : joinPaths([this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id, customId]);
    if (path === rootRouteId) {
      path = '/';
    }
    if (id !== rootRouteId) {
      id = joinPaths(['/', id]);
    }
    const fullPath = id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path]);
    this.path = path;
    this.id = id;
    // this.customId = customId as TCustomId
    this.fullPath = fullPath;
    this.to = fullPath;
  };
  addChildren = children => {
    this.children = children;
    return this;
  };
  useMatch = opts => {
    return useMatch({
      ...opts,
      from: this.id
    });
  };
  useLoader = opts => {
    return useLoader({
      ...opts,
      from: this.id
    });
  };
  useContext = opts => {
    return useMatch({
      ...opts,
      from: this.id,
      select: d => opts?.select?.(d.context) ?? d.context
    });
  };
  useSearch = opts => {
    return useSearch({
      ...opts,
      from: this.id
    });
  };
  useParams = opts => {
    return useParams({
      ...opts,
      from: this.id
    });
  };
}
class RouterContext {
  constructor() {}
  createRootRoute = options => {
    return new RootRoute(options);
  };

  //   return <
  //     TLoader = unknown,
  //     TSearchSchema extends AnySearchSchema = {},
  //     TContext extends {} = {},
  //   >(
  //     options?: Omit<
  //       RouteOptions<
  //         AnyRoute,
  //         RootRouteId,
  //         '',
  //         TLoader,
  //         {},
  //         TSearchSchema,
  //         NoInfer<TSearchSchema>,
  //         {},
  //         TRouterContext,
  //         TRouterContext,
  //         TContext,
  //         TRouterContext & TContext
  //       >,
  //       'path' | 'id' | 'getParentRoute' | 'caseSensitive'
  //     >,
  //   ) =>
  //     new RootRoute<TLoader, TSearchSchema, TContext, TRouterContext>(
  //       options as any,
  //     )
  // }
}

class RootRoute extends Route {
  constructor(options) {
    super(options);
  }
}

// const rootRoute = new RootRoute({
//   validateSearch: () => null as unknown as { root?: boolean },
// })

// const aRoute = new Route({
//   getParentRoute: () => rootRoute,
//   path: 'a',
//   validateSearch: () => null as unknown as { a?: string },
// })

// const bRoute = new Route({
//   getParentRoute: () => aRoute,
//   path: 'b',
// })

// const rootIsRoot = rootRoute.isRoot
// //    ^?
// const aIsRoot = aRoute.isRoot
// //    ^?

// const rId = rootRoute.id
// //    ^?
// const aId = aRoute.id
// //    ^?
// const bId = bRoute.id
// //    ^?

// const rPath = rootRoute.fullPath
// //    ^?
// const aPath = aRoute.fullPath
// //    ^?
// const bPath = bRoute.fullPath
// //    ^?

// const rSearch = rootRoute.__types.fullSearchSchema
// //    ^?
// const aSearch = aRoute.__types.fullSearchSchema
// //    ^?
// const bSearch = bRoute.__types.fullSearchSchema
// //    ^?

// const config = rootRoute.addChildren([aRoute.addChildren([bRoute])])
// //    ^?

const defaultParseSearch = parseSearchWith(JSON.parse);
const defaultStringifySearch = stringifySearchWith(JSON.stringify);
function parseSearchWith(parser) {
  return searchStr => {
    if (searchStr.substring(0, 1) === '?') {
      searchStr = searchStr.substring(1);
    }
    let query = decode(searchStr);

    // Try to parse any query params that might be json
    for (let key in query) {
      const value = query[key];
      if (typeof value === 'string') {
        try {
          query[key] = parser(value);
        } catch (err) {
          //
        }
      }
    }
    return query;
  };
}
function stringifySearchWith(stringify) {
  return search => {
    search = {
      ...search
    };
    if (search) {
      Object.keys(search).forEach(key => {
        const val = search[key];
        if (typeof val === 'undefined' || val === undefined) {
          delete search[key];
        } else if (val && typeof val === 'object' && val !== null) {
          try {
            search[key] = stringify(val);
          } catch (err) {
            // silent
          }
        }
      });
    }
    const searchStr = encode(search).toString();
    return searchStr ? `?${searchStr}` : '';
  };
}

const componentTypes = ['component', 'errorComponent', 'pendingComponent'];
class Router {
  #unsubHistory;
  startedLoadingAt = Date.now();
  resolveNavigation = () => {};
  constructor(options) {
    this.options = {
      defaultPreloadDelay: 50,
      context: undefined,
      ...options,
      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,
      parseSearch: options?.parseSearch ?? defaultParseSearch
      // fetchServerDataFn: options?.fetchServerDataFn ?? defaultFetchServerDataFn,
    };

    this.__store = new Store(getInitialRouterState(), {
      onUpdate: () => {
        this.state = this.__store.state;
      },
      defaultPriority: 'low'
    });
    this.state = this.__store.state;
    this.update(options);
    const next = this.buildNext({
      hash: true,
      fromCurrent: true,
      search: true,
      state: true
    });
    if (this.state.location.href !== next.href) {
      this.#commitLocation({
        ...next,
        replace: true
      });
    }
  }
  reset = () => {
    this.__store.setState(s => Object.assign(s, getInitialRouterState()));
  };
  mount = () => {
    // If the router matches are empty, start loading the matches
    if (!this.state.matches.length) {
      this.safeLoad();
    }
  };
  update = opts => {
    this.options = {
      ...this.options,
      ...opts,
      context: {
        ...this.options.context,
        ...opts?.context
      }
    };
    if (!this.history || this.options.history && this.options.history !== this.history) {
      if (this.#unsubHistory) {
        this.#unsubHistory();
      }
      this.history = this.options.history ?? (isServer ? createMemoryHistory() : createBrowserHistory());
      const parsedLocation = this.#parseLocation();
      this.__store.setState(s => ({
        ...s,
        resolvedLocation: parsedLocation,
        location: parsedLocation
      }));
      this.#unsubHistory = this.history.listen(() => {
        this.safeLoad({
          next: this.#parseLocation(this.state.location)
        });
      });
    }
    const {
      basepath,
      routeTree
    } = this.options;
    this.basepath = `/${trimPath(basepath ?? '') ?? ''}`;
    if (routeTree && routeTree !== this.routeTree) {
      this.#buildRouteTree(routeTree);
    }
    return this;
  };
  buildNext = opts => {
    const next = this.#buildLocation(opts);
    const __matches = this.matchRoutes(next.pathname, next.search);
    return this.#buildLocation({
      ...opts,
      __matches
    });
  };
  cancelMatches = () => {
    this.state.matches.forEach(match => {
      this.cancelMatch(match.id);
    });
  };
  cancelMatch = id => {
    this.getRouteMatch(id)?.abortController?.abort();
  };
  safeLoad = opts => {
    this.load(opts).catch(err => {
      // console.warn(err)
      // invariant(false, 'Encountered an error during router.load()! ☝️.')
    });
  };
  load = async opts => {
    this.#createNavigationPromise();
    let now = Date.now();
    const startedAt = now;
    this.startedLoadingAt = startedAt;

    // Cancel any pending matches
    this.cancelMatches();
    let pendingMatches;
    this.__store.batch(() => {
      if (opts?.next) {
        // Ingest the new location
        this.__store.setState(s => ({
          ...s,
          location: opts.next
        }));
      }

      // Match the routes
      pendingMatches = this.matchRoutes(this.state.location.pathname, this.state.location.search, {
        // throwOnError: true,
      });
      this.__store.setState(s => ({
        ...s,
        status: 'pending',
        pendingMatches
      }));
    });

    // Load the matches
    await this.loadMatches(pendingMatches);
    if (this.startedLoadingAt !== startedAt) {
      // Ignore side-effects of outdated side-effects
      return this.navigationPromise;
    }
    const prevLocation = this.state.resolvedLocation;
    this.__store.setState(s => ({
      ...s,
      status: 'idle',
      resolvedLocation: s.location,
      matches: s.pendingMatches,
      pendingMatches: []
    }));
    if (prevLocation.href !== this.state.location.href) {
      this.options.onRouteChange?.();
    }
    this.resolveNavigation();
  };
  getRoute = id => {
    const route = this.routesById[id];
    invariant(route, `Route with id "${id}" not found`);
    return route;
  };
  preloadRoute = async (navigateOpts = this.state.location) => {
    const next = this.buildNext(navigateOpts);
    const matches = this.matchRoutes(next.pathname, next.search, {
      throwOnError: true
    });
    const matchesById = {};
    matches.forEach(m => {
      if (!this.state.matches.find(d => d.id === m.id)) {
        matchesById[m.id] = m;
      }
    });
    this.__store.setState(s => {
      return {
        ...s,
        preloadMatches: {
          ...s.preloadMatches,
          ...matchesById
        }
      };
    });
    await this.loadMatches(matches, {
      preload: true
    });
    return matches;
  };
  matchRoutes = (pathname, locationSearch, opts) => {
    let routeParams = {};
    let foundRoute = this.flatRoutes.find(route => {
      const matchedParams = matchPathname(this.basepath, pathname, {
        to: route.fullPath,
        caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive
      });
      if (matchedParams) {
        routeParams = matchedParams;
        return true;
      }
      return false;
    });
    let routeCursor = foundRoute || this.routesById['__root__'];
    let matchedRoutes = [routeCursor];
    while (routeCursor?.parentRoute) {
      routeCursor = routeCursor.parentRoute;
      if (routeCursor) matchedRoutes.unshift(routeCursor);
    }

    // Alright, by now we should have all of our
    // matching routes and their param pairs, let's
    // Turn them into actual `Match` objects and
    // accumulate the params into a single params bag
    let allParams = {};

    // Existing matches are matches that are already loaded along with
    // pending matches that are still loading

    const matches = matchedRoutes.map(route => {
      let parsedParams;
      let parsedParamsError;
      try {
        parsedParams = route.options.parseParams?.(routeParams) ?? routeParams;
      } catch (err) {
        parsedParamsError = new PathParamError(err.message, {
          cause: err
        });
        if (opts?.throwOnError) {
          throw parsedParamsError;
        }
      }

      // Add the parsed params to the accumulated params bag
      Object.assign(allParams, parsedParams);
      const interpolatedPath = interpolatePath(route.path, allParams);
      const matchId = interpolatePath(route.id, allParams, true) + (route.options.getKey?.({
        params: allParams,
        search: locationSearch
      }) ?? '');

      // Waste not, want not. If we already have a match for this route,
      // reuse it. This is important for layout routes, which might stick
      // around between navigation actions that only change leaf routes.
      const existingMatch = this.getRouteMatch(matchId);
      if (existingMatch) {
        // Return a copy, we don't want to mutate the existing match
        return {
          ...existingMatch
        };
      }

      // Create a fresh route match
      const hasLoaders = !!(route.options.loader || componentTypes.some(d => route.options[d]?.preload));
      const routeMatch = {
        id: matchId,
        routeId: route.id,
        params: allParams,
        pathname: joinPaths([this.basepath, interpolatedPath]),
        updatedAt: 0,
        routeSearch: {},
        search: {},
        status: hasLoaders ? 'pending' : 'success',
        error: undefined,
        paramsError: parsedParamsError,
        searchError: undefined,
        loader: undefined,
        loadPromise: Promise.resolve(),
        routeContext: undefined,
        context: undefined,
        abortController: new AbortController(),
        fetchedAt: 0
      };
      return routeMatch;
    });

    // Take each match and resolve its search params and context
    // This has to happen after the matches are created or found
    // so that we can use the parent match's search params and context
    matches.forEach((match, i) => {
      const parentMatch = matches[i - 1];
      const route = this.getRoute(match.routeId);
      const searchInfo = (() => {
        // Validate the search params and stabilize them
        const parentSearchInfo = {
          search: parentMatch?.search ?? locationSearch,
          routeSearch: parentMatch?.routeSearch ?? locationSearch
        };
        try {
          const validator = typeof route.options.validateSearch === 'object' ? route.options.validateSearch.parse : route.options.validateSearch;
          const routeSearch = validator?.(parentSearchInfo.search) ?? {};
          const search = {
            ...parentSearchInfo.search,
            ...routeSearch
          };
          return {
            routeSearch: replaceEqualDeep(match.routeSearch, routeSearch),
            search: replaceEqualDeep(match.search, search)
          };
        } catch (err) {
          match.searchError = new SearchParamError(err.message, {
            cause: err
          });
          if (opts?.throwOnError) {
            throw match.searchError;
          }
          return parentSearchInfo;
        }
      })();
      const contextInfo = (() => {
        try {
          const routeContext = route.options.getContext?.({
            parentContext: parentMatch?.routeContext ?? {},
            context: parentMatch?.context ?? this?.options.context ?? {},
            params: match.params,
            search: match.search
          }) || {};
          const context = {
            ...(parentMatch?.context ?? this?.options.context),
            ...routeContext
          };
          return {
            context,
            routeContext
          };
        } catch (err) {
          route.options.onError?.(err);
          throw err;
        }
      })();
      Object.assign(match, {
        ...searchInfo,
        ...contextInfo
      });
    });
    return matches;
  };
  loadMatches = async (resolvedMatches, opts) => {
    let firstBadMatchIndex;

    // Check each match middleware to see if the route can be accessed
    try {
      await Promise.all(resolvedMatches.map(async (match, index) => {
        const route = this.getRoute(match.routeId);
        const handleError = (err, handler) => {
          firstBadMatchIndex = firstBadMatchIndex ?? index;
          handler = handler || route.options.onError;
          if (isRedirect(err)) {
            throw err;
          }
          try {
            handler?.(err);
          } catch (errorHandlerErr) {
            err = errorHandlerErr;
            if (isRedirect(errorHandlerErr)) {
              throw errorHandlerErr;
            }
          }
          this.setRouteMatch(match.id, s => ({
            ...s,
            error: err,
            status: 'error',
            updatedAt: Date.now()
          }));
        };
        if (match.paramsError) {
          handleError(match.paramsError, route.options.onParseParamsError);
        }
        if (match.searchError) {
          handleError(match.searchError, route.options.onValidateSearchError);
        }
        try {
          await route.options.beforeLoad?.({
            router: this,
            match
          });
        } catch (err) {
          handleError(err, route.options.onBeforeLoadError);
        }
      }));
    } catch (err) {
      if (isRedirect(err)) {
        if (!opts?.preload) {
          this.navigate(err);
        }
        return;
      }
      throw err; // we should never end up here
    }

    const validResolvedMatches = resolvedMatches.slice(0, firstBadMatchIndex);
    const matchPromises = [];
    validResolvedMatches.forEach((match, index) => {
      matchPromises.push(Promise.resolve().then(async () => {
        const parentMatchPromise = matchPromises[index - 1];
        const route = this.getRoute(match.routeId);
        const fetchedAt = Date.now();
        const loadPromise = Promise.resolve().then(async () => {
          const checkLatest = () => {
            const latest = this.getRouteMatch(match.id);
            return latest && latest.fetchedAt !== fetchedAt ? latest.loadPromise : undefined;
          };
          let latestPromise;
          const componentsPromise = (async () => {
            // then run all component and data loaders in parallel
            // For each component type, potentially load it asynchronously

            await Promise.all(componentTypes.map(async type => {
              const component = route.options[type];
              if (component?.preload) {
                await component.preload();
              }
            }));
          })();
          const loaderPromise = Promise.resolve().then(() => {
            if (route.options.loader) {
              return route.options.loader({
                ...match,
                preload: !!opts?.preload,
                parentMatchPromise
              });
            }
            return;
          });
          try {
            const [_, loader] = await Promise.all([componentsPromise, loaderPromise]);
            if (latestPromise = checkLatest()) return await latestPromise;
            if (!opts?.preload || !this.state.matches.find(d => d.id === match.id)) {
              this.setRouteMatch(match.id, s => ({
                ...s,
                error: undefined,
                status: 'success',
                updatedAt: Date.now(),
                loader
              }));
            }
          } catch (err) {
            if (latestPromise = checkLatest()) return await latestPromise;
            if (isRedirect(err)) {
              if (!opts?.preload) {
                this.navigate(err);
              }
              return;
            }
            const errorHandler = route.options.onLoadError ?? route.options.onError;
            let caughtError = err;
            try {
              errorHandler?.(err);
            } catch (errorHandlerErr) {
              caughtError = errorHandlerErr;
              if (isRedirect(errorHandlerErr)) {
                if (!opts?.preload) {
                  this.navigate(errorHandlerErr);
                }
                return;
              }
            }
            this.setRouteMatch(match.id, s => ({
              ...s,
              error: caughtError,
              status: 'error',
              updatedAt: Date.now()
            }));
          } finally {
            if (latestPromise = checkLatest()) return await latestPromise;
            if (opts?.preload) {
              this.__store.setState(s => {
                const preloadMatches = {
                  ...s.preloadMatches
                };
                delete preloadMatches[match.id];
                return {
                  ...s,
                  preloadMatches
                };
              });
            }
          }
        });
        this.setRouteMatch(match.id, s => ({
          ...s,
          loadPromise,
          fetchedAt
        }));
        await loadPromise;
      }));
    });
    await Promise.all(matchPromises);
  };
  reload = () => {
    this.navigate({
      fromCurrent: true,
      replace: true,
      search: true
    });
  };
  resolvePath = (from, path) => {
    return resolvePath(this.basepath, from, cleanPath(path));
  };
  navigate = async ({
    from,
    to = '',
    search,
    hash,
    replace,
    params
  }) => {
    // If this link simply reloads the current route,
    // make sure it has a new key so it will trigger a data refresh

    // If this `to` is a valid external URL, return
    // null for LinkUtils
    const toString = String(to);
    const fromString = typeof from === 'undefined' ? from : String(from);
    let isExternal;
    try {
      new URL(`${toString}`);
      isExternal = true;
    } catch (e) {}
    invariant(!isExternal, 'Attempting to navigate to external url with this.navigate!');
    return this.#commitLocation({
      from: fromString,
      to: toString,
      search,
      hash,
      replace,
      params
    });
  };
  matchRoute = (location, opts) => {
    location = {
      ...location,
      to: location.to ? this.resolvePath(location.from ?? '', location.to) : undefined
    };
    const next = this.buildNext(location);
    if (opts?.pending && this.state.status !== 'pending') {
      return false;
    }
    const baseLocation = opts?.pending ? this.state.location : this.state.resolvedLocation;
    if (!baseLocation) {
      return false;
    }
    const match = matchPathname(this.basepath, baseLocation.pathname, {
      ...opts,
      to: next.pathname
    });
    if (!match) {
      return false;
    }
    if (opts?.includeSearch ?? true) {
      return partialDeepEqual(baseLocation.search, next.search) ? match : false;
    }
    return match;
  };
  buildLink = ({
    from,
    to = '.',
    search,
    params,
    hash,
    target,
    replace,
    activeOptions,
    preload,
    preloadDelay: userPreloadDelay,
    disabled
  }) => {
    // If this link simply reloads the current route,
    // make sure it has a new key so it will trigger a data refresh

    // If this `to` is a valid external URL, return
    // null for LinkUtils

    try {
      new URL(`${to}`);
      return {
        type: 'external',
        href: to
      };
    } catch (e) {}
    const nextOpts = {
      from,
      to,
      search,
      params,
      hash,
      replace
    };
    const next = this.buildNext(nextOpts);
    preload = preload ?? this.options.defaultPreload;
    const preloadDelay = userPreloadDelay ?? this.options.defaultPreloadDelay ?? 0;

    // Compare path/hash for matches
    const currentPathSplit = this.state.location.pathname.split('/');
    const nextPathSplit = next.pathname.split('/');
    const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);
    // Combine the matches based on user options
    const pathTest = activeOptions?.exact ? this.state.location.pathname === next.pathname : pathIsFuzzyEqual;
    const hashTest = activeOptions?.includeHash ? this.state.location.hash === next.hash : true;
    const searchTest = activeOptions?.includeSearch ?? true ? partialDeepEqual(this.state.location.search, next.search) : true;

    // The final "active" test
    const isActive = pathTest && hashTest && searchTest;

    // The click handler
    const handleClick = e => {
      if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {
        e.preventDefault();

        // All is well? Navigate!
        this.#commitLocation(nextOpts);
      }
    };

    // The click handler
    const handleFocus = e => {
      if (preload) {
        this.preloadRoute(nextOpts).catch(err => {
          console.warn(err);
          console.warn('Error preloading route! ☝️');
        });
      }
    };
    const handleTouchStart = e => {
      this.preloadRoute(nextOpts).catch(err => {
        console.warn(err);
        console.warn('Error preloading route! ☝️');
      });
    };
    const handleEnter = e => {
      const target = e.target || {};
      if (preload) {
        if (target.preloadTimeout) {
          return;
        }
        target.preloadTimeout = setTimeout(() => {
          target.preloadTimeout = null;
          this.preloadRoute(nextOpts).catch(err => {
            console.warn(err);
            console.warn('Error preloading route! ☝️');
          });
        }, preloadDelay);
      }
    };
    const handleLeave = e => {
      const target = e.target || {};
      if (target.preloadTimeout) {
        clearTimeout(target.preloadTimeout);
        target.preloadTimeout = null;
      }
    };
    return {
      type: 'internal',
      next,
      handleFocus,
      handleClick,
      handleEnter,
      handleLeave,
      handleTouchStart,
      isActive,
      disabled
    };
  };
  dehydrate = () => {
    return {
      state: pick(this.state, ['location', 'status', 'lastUpdated'])
    };
  };
  hydrate = async __do_not_use_server_ctx => {
    let _ctx = __do_not_use_server_ctx;
    // Client hydrates from window
    if (typeof document !== 'undefined') {
      _ctx = window.__TSR_DEHYDRATED__;
    }
    invariant(_ctx, 'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?');
    const ctx = _ctx;
    this.dehydratedData = ctx.payload;
    this.options.hydrate?.(ctx.payload);
    this.__store.setState(s => {
      return {
        ...s,
        ...ctx.router.state,
        matches: s.matches,
        resolvedLocation: ctx.router.state.location
      };
    });
    await this.load();
    return;
  };
  injectedHtml = [];
  injectHtml = async html => {
    this.injectedHtml.push(html);
  };
  dehydrateData = (key, getData) => {
    if (typeof document === 'undefined') {
      const strKey = typeof key === 'string' ? key : JSON.stringify(key);
      this.injectHtml(async () => {
        const id = `__TSR_DEHYDRATED__${strKey}`;
        const data = typeof getData === 'function' ? await getData() : getData;
        return `<script id='${id}' suppressHydrationWarning>window["__TSR_DEHYDRATED__${escapeJSON(strKey)}"] = ${JSON.stringify(data)}
        ;(() => {
          var el = document.getElementById('${id}')
          el.parentElement.removeChild(el)
        })()
        </script>`;
      });
      return () => this.hydrateData(key);
    }
    return () => undefined;
  };
  hydrateData = key => {
    if (typeof document !== 'undefined') {
      const strKey = typeof key === 'string' ? key : JSON.stringify(key);
      return window[`__TSR_DEHYDRATED__${strKey}`];
    }
    return undefined;
  };

  // resolveMatchPromise = (matchId: string, key: string, value: any) => {
  //   this.state.matches
  //     .find((d) => d.id === matchId)
  //     ?.__promisesByKey[key]?.resolve(value)
  // }

  #buildRouteTree = routeTree => {
    this.routeTree = routeTree;
    this.routesById = {};
    this.routesByPath = {};
    this.flatRoutes = [];
    const recurseRoutes = routes => {
      routes.forEach((route, i) => {
        route.init({
          originalIndex: i,
          router: this
        });
        const existingRoute = this.routesById[route.id];
        invariant(!existingRoute, `Duplicate routes found with id: ${String(route.id)}`);
        this.routesById[route.id] = route;
        if (!route.isRoot && route.path) {
          const trimmedFullPath = trimPathRight(route.fullPath);
          if (!this.routesByPath[trimmedFullPath] || route.fullPath.endsWith('/')) {
            this.routesByPath[trimmedFullPath] = route;
          }
        }
        const children = route.children;
        if (children?.length) {
          recurseRoutes(children);
        }
      });
    };
    recurseRoutes([routeTree]);
    this.flatRoutes = Object.values(this.routesByPath).map((d, i) => {
      const trimmed = trimPath(d.fullPath);
      const parsed = parsePathname(trimmed);
      while (parsed.length > 1 && parsed[0]?.value === '/') {
        parsed.shift();
      }
      const score = parsed.map(d => {
        if (d.type === 'param') {
          return 0.5;
        }
        if (d.type === 'wildcard') {
          return 0.25;
        }
        return 1;
      });
      return {
        child: d,
        trimmed,
        parsed,
        index: i,
        score
      };
    }).sort((a, b) => {
      let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0;
      if (isIndex !== 0) return isIndex;
      const length = Math.min(a.score.length, b.score.length);

      // Sort by length of score
      if (a.score.length !== b.score.length) {
        return b.score.length - a.score.length;
      }

      // Sort by min available score
      for (let i = 0; i < length; i++) {
        if (a.score[i] !== b.score[i]) {
          return b.score[i] - a.score[i];
        }
      }

      // Sort by min available parsed value
      for (let i = 0; i < length; i++) {
        if (a.parsed[i].value !== b.parsed[i].value) {
          return a.parsed[i].value > b.parsed[i].value ? 1 : -1;
        }
      }

      // Sort by length of trimmed full path
      if (a.trimmed !== b.trimmed) {
        return a.trimmed > b.trimmed ? 1 : -1;
      }

      // Sort by original index
      return a.index - b.index;
    }).map((d, i) => {
      d.child.rank = i;
      return d.child;
    });
  };
  #parseLocation = previousLocation => {
    let {
      pathname,
      search,
      hash,
      state
    } = this.history.location;
    const parsedSearch = this.options.parseSearch(search);
    return {
      pathname: pathname,
      searchStr: search,
      search: replaceEqualDeep(previousLocation?.search, parsedSearch),
      hash: hash.split('#').reverse()[0] ?? '',
      href: `${pathname}${search}${hash}`,
      state: state,
      key: state?.key || '__init__'
    };
  };
  #buildLocation = (dest = {}) => {
    dest.fromCurrent = dest.fromCurrent ?? dest.to === '';
    const fromPathname = dest.fromCurrent ? this.state.location.pathname : dest.from ?? this.state.location.pathname;
    let pathname = resolvePath(this.basepath ?? '/', fromPathname, `${dest.to ?? ''}`);
    const fromMatches = this.matchRoutes(this.state.location.pathname, this.state.location.search);
    const prevParams = {
      ...last(fromMatches)?.params
    };
    let nextParams = (dest.params ?? true) === true ? prevParams : functionalUpdate(dest.params, prevParams);
    if (nextParams) {
      dest.__matches?.map(d => this.getRoute(d.routeId).options.stringifyParams).filter(Boolean).forEach(fn => {
        nextParams = {
          ...nextParams,
          ...fn(nextParams)
        };
      });
    }
    pathname = interpolatePath(pathname, nextParams ?? {});
    const preSearchFilters = dest.__matches?.map(match => this.getRoute(match.routeId).options.preSearchFilters ?? []).flat().filter(Boolean) ?? [];
    const postSearchFilters = dest.__matches?.map(match => this.getRoute(match.routeId).options.postSearchFilters ?? []).flat().filter(Boolean) ?? [];

    // Pre filters first
    const preFilteredSearch = preSearchFilters?.length ? preSearchFilters?.reduce((prev, next) => next(prev), this.state.location.search) : this.state.location.search;

    // Then the link/navigate function
    const destSearch = dest.search === true ? preFilteredSearch // Preserve resolvedFrom true
    : dest.search ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater
    : preSearchFilters?.length ? preFilteredSearch // Preserve resolvedFrom filters
    : {};

    // Then post filters
    const postFilteredSearch = postSearchFilters?.length ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;
    const search = replaceEqualDeep(this.state.location.search, postFilteredSearch);
    const searchStr = this.options.stringifySearch(search);
    const hash = dest.hash === true ? this.state.location.hash : functionalUpdate(dest.hash, this.state.location.hash);
    const hashStr = hash ? `#${hash}` : '';
    const nextState = dest.state === true ? this.state.location.state : functionalUpdate(dest.state, this.state.location.state);
    return {
      pathname,
      search,
      searchStr,
      state: nextState,
      hash,
      href: this.history.createHref(`${pathname}${searchStr}${hashStr}`),
      key: dest.key
    };
  };
  #commitLocation = async location => {
    const next = this.buildNext(location);
    const id = '' + Date.now() + Math.random();
    if (this.navigateTimeout) clearTimeout(this.navigateTimeout);
    let nextAction = 'replace';
    if (!location.replace) {
      nextAction = 'push';
    }
    const isSameUrl = this.state.location.href === next.href;
    if (isSameUrl && !next.key) {
      nextAction = 'replace';
    }
    const href = `${next.pathname}${next.searchStr}${next.hash ? `#${next.hash}` : ''}`;
    this.history[nextAction === 'push' ? 'push' : 'replace'](href, {
      id,
      ...next.state
    });
    return this.#createNavigationPromise();
  };
  #createNavigationPromise = () => {
    const previousNavigationResolve = this.resolveNavigation;
    this.navigationPromise = new Promise(resolve => {
      this.resolveNavigation = () => {
        resolve();
        previousNavigationResolve();
      };
    });
    return this.navigationPromise;
  };
  getRouteMatch = id => {
    return this.state.matches.find(d => d.id === id) || this.state.preloadMatches[id];
  };
  #setResolvedRouteMatch = (id, updater) => {
    this.__store.setState(prev => ({
      ...prev,
      matches: prev.matches.map(d => {
        if (d.id === id) {
          return updater(d);
        }
        return d;
      })
    }));
  };
  #setPendingRouteMatch = (id, updater) => {
    this.__store.setState(prev => ({
      ...prev,
      pendingMatches: prev.pendingMatches.map(d => {
        if (d.id === id) {
          return updater(d);
        }
        return d;
      })
    }));
  };
  #setPreloadRouteMatch = (id, updater) => {
    invariant(this.state.preloadMatches[id], 'Match not found');
    this.__store.setState(prev => ({
      ...prev,
      preloadMatches: {
        ...prev.preloadMatches,
        [id]: updater(prev.preloadMatches[id])
      }
    }));
  };
  setRouteMatch = (id, updater) => {
    if (this.state.matches.find(d => d.id === id)) {
      return this.#setResolvedRouteMatch(id, updater);
    }
    if (this.state.pendingMatches.find(d => d.id === id)) {
      return this.#setPendingRouteMatch(id, updater);
    }
    if (this.state.preloadMatches[id]) {
      return this.#setPreloadRouteMatch(id, updater);
    }
  };
}

// Detect if we're in the DOM
const isServer = typeof window === 'undefined' || !window.document.createElement;
function getInitialRouterState() {
  return {
    status: 'idle',
    resolvedLocation: null,
    location: null,
    matches: [],
    pendingMatches: [],
    preloadMatches: {},
    lastUpdated: Date.now()
  };
}
function isCtrlEvent(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function redirect(opts) {
  opts.isRedirect = true;
  return opts;
}
function isRedirect(obj) {
  return !!obj?.isRedirect;
}
class SearchParamError extends Error {}
class PathParamError extends Error {}
function escapeJSON(jsonString) {
  return jsonString.replace(/\\/g, '\\\\') // Escape backslashes
  .replace(/'/g, "\\'") // Escape single quotes
  .replace(/"/g, '\\"'); // Escape double quotes
}

export { Block, ErrorComponent, Link, MatchRoute, Navigate, Outlet, PathParamError, RootRoute, Route, Router, RouterContext, RouterProvider, SearchParamError, cleanPath, componentTypes, createBrowserHistory, createHashHistory, createMemoryHistory, decode, defaultParseSearch, defaultStringifySearch, encode, functionalUpdate, interpolatePath, isPlainObject, isRedirect, joinPaths, last, lazy, matchByPath, matchIdsContext, matchPathname, parsePathname, parseSearchWith, partialDeepEqual, pick, redirect, replaceEqualDeep, resolvePath, rootRouteId, routerContext, shallow, stringifySearchWith, trimPath, trimPathLeft, trimPathRight, useBlocker, useDehydrate, useHydrate, useInjectHtml, useLinkProps, useLoader, useMatch, useMatchRoute, useMatches, useNavigate, useParams, useRouter, useRouterState, useSearch };
//# sourceMappingURL=index.js.map
