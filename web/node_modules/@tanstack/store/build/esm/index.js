/**
 * @tanstack/store/src/index.ts
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
class Store {
  listeners = new Set();
  _batching = false;
  _flushing = 0;
  _nextPriority = null;
  constructor(initialState, options) {
    this.state = initialState;
    this.options = options;
  }
  subscribe = listener => {
    this.listeners.add(listener);
    const unsub = this.options?.onSubscribe?.(listener, this);
    return () => {
      this.listeners.delete(listener);
      unsub?.();
    };
  };
  setState = (updater, opts) => {
    const previous = this.state;
    this.state = this.options?.updateFn ? this.options.updateFn(previous)(updater) : updater(previous);
    const priority = opts?.priority ?? this.options?.defaultPriority ?? 'high';
    if (this._nextPriority === null) {
      this._nextPriority = priority;
    } else if (this._nextPriority === 'high') {
      this._nextPriority = priority;
    } else {
      this._nextPriority = this.options?.defaultPriority ?? 'high';
    }

    // Always run onUpdate, regardless of batching
    this.options?.onUpdate?.({
      priority: this._nextPriority
    });

    // Attempt to flush
    this._flush();
  };
  _flush = () => {
    if (this._batching) return;
    const flushId = ++this._flushing;
    this.listeners.forEach(listener => {
      if (this._flushing !== flushId) return;
      listener({
        priority: this._nextPriority ?? 'high'
      });
    });
  };
  batch = cb => {
    if (this._batching) return cb();
    this._batching = true;
    cb();
    this._batching = false;
    this._flush();
  };
}

export { Store };
//# sourceMappingURL=index.js.map
