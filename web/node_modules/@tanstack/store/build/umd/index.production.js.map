{"version":3,"file":"index.production.js","sources":["../../src/index.ts"],"sourcesContent":["export type AnyUpdater = (...args: any[]) => any\n\nexport type Listener = (opts: { priority: Priority }) => void\n\nexport type Priority = 'high' | 'low'\n\ninterface StoreOptions<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  updateFn?: (previous: TState) => (updater: TUpdater) => TState\n  onSubscribe?: (\n    listener: Listener,\n    store: Store<TState, TUpdater>,\n  ) => () => void\n  onUpdate?: (opts: { priority: Priority }) => void\n  defaultPriority?: Priority\n}\n\nexport class Store<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  listeners = new Set<Listener>()\n  state: TState\n  options?: StoreOptions<TState, TUpdater>\n  _batching = false\n  _flushing = 0\n  _nextPriority: null | Priority = null\n\n  constructor(initialState: TState, options?: StoreOptions<TState, TUpdater>) {\n    this.state = initialState\n    this.options = options\n  }\n\n  subscribe = (listener: Listener) => {\n    this.listeners.add(listener)\n    const unsub = this.options?.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n\n  setState = (\n    updater: TUpdater,\n    opts?: {\n      priority: Priority\n    },\n  ) => {\n    const previous = this.state\n    this.state = this.options?.updateFn\n      ? this.options.updateFn(previous)(updater)\n      : (updater as any)(previous)\n\n    const priority = opts?.priority ?? this.options?.defaultPriority ?? 'high'\n    if (this._nextPriority === null) {\n      this._nextPriority = priority\n    } else if (this._nextPriority === 'high') {\n      this._nextPriority = priority\n    } else {\n      this._nextPriority = this.options?.defaultPriority ?? 'high'\n    }\n\n    // Always run onUpdate, regardless of batching\n    this.options?.onUpdate?.({\n      priority: this._nextPriority,\n    })\n\n    // Attempt to flush\n    this._flush()\n  }\n\n  _flush = () => {\n    if (this._batching) return\n    const flushId = ++this._flushing\n    this.listeners.forEach((listener) => {\n      if (this._flushing !== flushId) return\n      listener({\n        priority: this._nextPriority ?? 'high',\n      })\n    })\n  }\n\n  batch = (cb: () => void) => {\n    if (this._batching) return cb()\n    this._batching = true\n    cb()\n    this._batching = false\n    this._flush()\n  }\n}\n"],"names":["listeners","Set","_batching","_flushing","_nextPriority","constructor","initialState","options","this","state","subscribe","listener","add","unsub","onSubscribe","delete","setState","updater","opts","previous","updateFn","priority","defaultPriority","onUpdate","_flush","flushId","forEach","batch","cb"],"mappings":";;;;;;;;;;qPAmBO,MAILA,UAAY,IAAIC,IAGhBC,WAAY,EACZC,UAAY,EACZC,cAAiC,KAEjCC,YAAYC,EAAsBC,GAChCC,KAAKC,MAAQH,EACbE,KAAKD,QAAUA,CACjB,CAEAG,UAAaC,IACXH,KAAKR,UAAUY,IAAID,GACnB,MAAME,EAAQL,KAAKD,SAASO,cAAcH,EAAUH,MACpD,MAAO,KACLA,KAAKR,UAAUe,OAAOJ,GACtBE,KAAS,CACV,EAGHG,SAAW,CACTC,EACAC,KAIA,MAAMC,EAAWX,KAAKC,MACtBD,KAAKC,MAAQD,KAAKD,SAASa,SACvBZ,KAAKD,QAAQa,SAASD,EAAtBX,CAAgCS,GAC/BA,EAAgBE,GAErB,MAAME,EAAWH,GAAMG,UAAYb,KAAKD,SAASe,iBAAmB,OACzC,OAAvBd,KAAKJ,eAEyB,SAAvBI,KAAKJ,cADdI,KAAKJ,cAAgBiB,EAIrBb,KAAKJ,cAAgBI,KAAKD,SAASe,iBAAmB,OAIxDd,KAAKD,SAASgB,WAAW,CACvBF,SAAUb,KAAKJ,gBAIjBI,KAAKgB,QAAQ,EAGfA,OAAS,KACP,GAAIhB,KAAKN,UAAW,OACpB,MAAMuB,IAAYjB,KAAKL,UACvBK,KAAKR,UAAU0B,SAASf,IAClBH,KAAKL,YAAcsB,GACvBd,EAAS,CACPU,SAAUb,KAAKJ,eAAiB,QAChC,GACF,EAGJuB,MAASC,IACP,GAAIpB,KAAKN,UAAW,OAAO0B,IAC3BpB,KAAKN,WAAY,EACjB0B,IACApB,KAAKN,WAAY,EACjBM,KAAKgB,QAAQ"}